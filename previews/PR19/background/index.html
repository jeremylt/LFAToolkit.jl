<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mathematical Background · LFAToolkit.jl</title><link rel="canonical" href="https://jeremylt.github.io/LFAToolkit.jl/stable/background/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LFAToolkit.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Mathematical Background</a><ul class="internal"><li><a class="tocitem" href="#Local-Fourier-Analysis"><span>Local Fourier Analysis</span></a></li><li><a class="tocitem" href="#High-Order-Finite-Elements"><span>High Order Finite Elements</span></a></li><li><a class="tocitem" href="#Multigrid"><span>Multigrid</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../public/">Public API</a></li><li><a class="tocitem" href="../private/">Private API</a></li><li><a class="tocitem" href="../release_notes/">Release Notes</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Mathematical Background</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mathematical Background</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jeremylt/LFAToolkit.jl/blob/master/docs/src/background.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Mathematical-Background"><a class="docs-heading-anchor" href="#Mathematical-Background">Mathematical Background</a><a id="Mathematical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background" title="Permalink"></a></h1><p>Local Fourier Analysis (LFA) was first used by Brandt [1] to analyze the convergence of multi-level adaptive techniques for solving PDEs discretized with finite differences, but the technique has been adapted for multi-level and multi-grid techniques using finite element discretizations. While this library focuses on the finite element discretizations, finite difference discretizations of PDEs can often be recovered from finite element formulations by using linear finite elements on a structured grid. This fact makes LFAToolkit.jl an extremely flexible tool for LFA.</p><h2 id="Local-Fourier-Analysis"><a class="docs-heading-anchor" href="#Local-Fourier-Analysis">Local Fourier Analysis</a><a id="Local-Fourier-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Fourier-Analysis" title="Permalink"></a></h2><p>LFA considers the local properties of the descretized system via its Fourier modes and the eigenvalues of the associated symbol matrix. We will describe the arbitrary degree, one dimensional scalar case and extend it to an arbitrary dimension and number of components finite element problem.</p><p>First consider a scalar Toeplitz operator <span>$L_h$</span> on an infinite one dimensional uniform grid <span>$G_h$</span>, This operator is given by</p><div>\[L_h \mathrel{\hat{=}} \left[ s_\kappa \right]_h \left( \kappa \in V \right)\\
L_h w_h \left( x \right) = \sum_{\kappa \in V} s_\kappa w_h \left( x + \kappa h \right)\]</div><p>where <span>$V \subset \mathcal{Z}$</span> is a finite index set, <span>$s_\kappa \in \mathcal{R}$</span> are constant coefficients and <span>$w_h \left( x \right)$</span> is a <span>$l^2$</span> function on <span>$G_h$</span>.</p><p>As <span>$L_h$</span> is Toeplitz, it can be diagonalized by the standard Fourier modes <span>$\varphi \left( \theta, x \right) = e^{\imath \theta x / h}$</span>.</p><p>If for all grid functions <span>$\varphi \left( \theta, x \right)$</span> we have</p><div>\[L_h \varphi \left( \theta, x \right) = \tilde{L}_h \left( \theta \right) \varphi \left( \theta, x \right)\]</div><p>then <span>$\tilde{L}_h \left( \theta \right) = \sum_{\kappa \in V} s_\kappa e^{\imath \theta \kappa}$</span> is the <strong>symbol</strong> of <span>$L_h$</span>.</p><p>We can extend this to a <span>$p \times p$</span> linear system of operators representing a scalar problem on a <span>$p$</span> order finite element</p><div>\[\tilde{L}_h =
\begin{bmatrix}
    \tilde{L}_h^{1, 1}  &amp;&amp;  \cdots  &amp;&amp;  \tilde{L}_h^{1, p}  \\
    \vdots              &amp;&amp;  \vdots  &amp;&amp;  \vdots              \\
    \tilde{L}_h^{p, 1}  &amp;&amp;  \cdots  &amp;&amp;  \tilde{L}_h^{p, p}  \\
\end{bmatrix}\]</div><p>where <span>$\tilde{L}_h^{i, j}$</span> is given by a scalar Toeplitz operator describing how component <span>$j$</span> appears in the equation for component <span>$i$</span>.</p><p>The spectral radius of the symbol of an error propagation operator determines how rapidly a relaxation scheme decreases error at a target frequency for a given parameter value. In this context, low frequencies are given by <span>$\theta \in T^{low} = \left[ - \pi / 2, \pi / 2 \right)$</span> and high frequencies are given by <span>$\theta \in T^{high} = \left[ - \pi / 2, 3 \pi / 2 \right) \setminus T^{low}$</span>.</p><h2 id="High-Order-Finite-Elements"><a class="docs-heading-anchor" href="#High-Order-Finite-Elements">High Order Finite Elements</a><a id="High-Order-Finite-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#High-Order-Finite-Elements" title="Permalink"></a></h2><p>Consider the specific case of a Topeliz operator representing a scalar PDE in 1D with the weak formulation given by Brown in [2],</p><div>\[\int_{\Omega} v \cdot f_0 \left( u, \nabla u \right) + \nabla v : f_1 \left( u, \nabla u \right) = \int_{\Omega} f v, \forall v \in V\]</div><p>for some suitable <span>$V \subseteq H_0^1 \left( \Omega \right)$</span>. In this equation, <span>$\cdot$</span> represents contraction over fields and <span>$:$</span> represents contraction over fields and spatial dimensions, both of which are omitted for the sake of clarity in this initial derivation. Boundary terms have been omitted, as they are not present on the infinite uniform grid <span>$G_h$</span>.</p><p>Selecting a finite element basis, we can discretize the weak form and produce</p><div>\[A u = b.\]</div><p>Using the algebraic representation of PDE operators discussed in [2], the PDE operator <span>$A$</span> is of the form</p><div>\[A = P^T A_e P\]</div><div>\[A_e = B^T D B\]</div><p>where <span>$P$</span> represents the element assembly operator, <span>$B$</span> is a basis operator which computes the values and derivatives of the basis functions at the quadrature points, and <span>$D$</span> is a block diagonal operator which provides a pointwise application of the bilinear form on the quadrature points, to include quadrature weights and the change in coordinates between the physical and reference space.</p><p>We can thus compute the symbol matrix as</p><div>\[\tilde{A}_h = Q^T \left( A_e \odot \left[ e^{\imath \left( x_i - x_j \right) \theta / h} \right] \right) Q\]</div><p>where <span>$\odot$</span> represents pointwise multiplication of the elements, <span>$h$</span> is the length of the element, and <span>$i, j \in \left[ 0, 1, \dots, p \right]$</span>. <span>$Q$</span> is a <span>$p + 1 \times p$</span> matrix that localizes Fourier modes on an element.</p><div>\[Q =
\begin{bmatrix}
    I    \\
    e_0  \\
\end{bmatrix} =
\begin{bmatrix}
    1       &amp;&amp;  0       &amp;&amp;  \cdots  &amp;&amp;  0       \\
    0       &amp;&amp;  1       &amp;&amp;  \cdots  &amp;&amp;  0       \\
    \vdots  &amp;&amp;  \vdots  &amp;&amp;  \vdots  &amp;&amp;  \vdots  \\
    0       &amp;&amp;  0       &amp;&amp;  \cdots  &amp;&amp;  1       \\
    1       &amp;&amp;  0       &amp;&amp;  \cdots  &amp;&amp;  0       \\
\end{bmatrix}\]</div><p>This same computation of the symbol matrix extends to more complex PDE with multiple components and in higher dimensions.</p><p>Multiple components are supported by extending the <span>$p \times p$</span> system of Toeplitz operators given above to a <span>$ncomp \cdot p \times ncomp \cdot p$</span> system of operators.</p><p>Tensor products are used to extend this analysis into higher dimensions. The basis evaluation operators in higher dimensions are given by</p><div>\[B_{interp2d} = B_{interp} \otimes B_{interp}\\
B_{grad2d} =
\begin{bmatrix}
    B_{grad} \otimes B_{interp}  \\
    B_{interp} \otimes B_{grad}  \\
\end{bmatrix}\]</div><p>where <span>$B_{interp}$</span> and <span>$B_{grad}$</span> represent 1D basis interpolation and gradient operators, respectively.</p><p>Similarly, the localization of Fourier modes in higher dimensions is given by</p><div>\[Q_{2d} = Q \otimes Q\]</div><p>and an analogous computation can be done for 3D.</p><p>Therefore, the symbol matrix for a PDE with arbitrary dimension, order and number of components is given by</p><div>\[\tilde{A}_h = Q^T \left( A_e \odot \left[ e^{\imath \sum_d \left( \mathbf{x}_i - \mathbf{x}_j \right) \mathbf{\theta} / \mathbf{h}} \right] \right) Q\]</div><p>where <span>$\odot$</span> represents pointwise multiplication of the elements, <span>$h$</span> is the length of the element in each dimension, and <span>$i, j \in \left[ 0, 1, \dots, p \right]$</span>. <span>$Q$</span> is a <span>$p - 1 \times p$</span> matrix that localizes the Fourier modes on the element.</p><h2 id="Multigrid"><a class="docs-heading-anchor" href="#Multigrid">Multigrid</a><a id="Multigrid-1"></a><a class="docs-heading-anchor-permalink" href="#Multigrid" title="Permalink"></a></h2><p>Multigrid follows the following algorithm:</p><ol><li><p>pre-smooth   : <span>$u_i := u_i + M^{-1} \left( b - A u_i \right)$</span></p></li><li><p>restrict     : <span>$r_c := R_{ftoc} \left( b - A u_i \right)$</span></p></li><li><p>coarse solve : <span>$A_c e_c := r_c$</span></p></li><li><p>prolongate   : <span>$u_i := u_i + P_{ctof} e_c$</span></p></li><li><p>post-smooth  : <span>$u_i := u_i + M^{-1} \left( b - A u_i \right)$</span></p></li></ol><p>where <span>$f$</span> and <span>$c$</span> represent the fine and coarse grids, respectively, <span>$R_{ftoc}$</span> represents the grid restriction operator, <span>$P_{ctof}$</span> represents the grid prolongation operator.</p><p>The total multigrid error propagation operator is given by</p><div>\[M_{TMG} = S_f \left( I - P_{ctof} A_c^{-1} R_{ftoc} A_f \right) S_f\]</div><p>where <span>$S_f$</span> represents the error propagation operator for the smoother on the fine grid.</p><p>This algorithm describes both h-multigrid and p-multigrid. While h-multigrid coarsens the mesh by increasing the size of each element, p-multigrid coarsens the mesh by decreasing the order of each element.</p><p>To explore the convergence of multigrid techniques, we need to analyze the symbol of the multigrid error propagation operator. We build the symbol of the p-multigrid error propagation operator in parts.</p><h3 id="Smoothing-Operator"><a class="docs-heading-anchor" href="#Smoothing-Operator">Smoothing Operator</a><a id="Smoothing-Operator-1"></a><a class="docs-heading-anchor-permalink" href="#Smoothing-Operator" title="Permalink"></a></h3><p>Multigrid techniques require error relaxation techniques. The error propagation operator for a relaxation technique is given by</p><div>\[S = I - M^{-1} A.\]</div><p>In the specific case of Jacobi smoothing, <span>$M$</span> is given by <span>$M = diag \left( A \right)$</span>.</p><p>The symbol of the error propagation operator is given by</p><div>\[\tilde{S}_h \left( \omega, \theta \right) = I - \tilde{M}_h^{-1} \left( \omega \right) \tilde{A}_h \left( \theta \right)\]</div><p>where <span>$\omega$</span> is a relaxation parameter.</p><p>Specifically, for Jacobi we have</p><div>\[\tilde{S}_h \left( \omega, \theta \right) = I - \omega \tilde{M}_h^{-1} \tilde{A}_h \left( \theta \right)\]</div><p>where <span>$\omega$</span> is the weighting factor and <span>$\tilde{M}_h$</span> is given by</p><div>\[\tilde{M}_h = Q^T diag \left( A_e \right) Q.\]</div><p>If multiple pre or post-smoothing passes are used, we have</p><div>\[\tilde{S}_h \left( \omega, \nu, \theta \right) = \left( I - \omega \tilde{M}_h^{-1} \tilde{A}_h \left( \theta \right) \right)^{\nu}\]</div><p>where <span>$\nu$</span> is the number of smoothing passes.</p><p>More sophisticated smoothers can be used, such as the Chebyshev semi-iterative method. For discussion of the error propegation of the Chebyshev semi-iteative method, see Gutknecht and Röllin [3]. User defined smoothers are supported, where the user provides <span>$M^{-1}$</span> or a function computing <span>$M^{-1}$</span> based upon <span>$A$</span>, and <span>$\tilde{M}^{-1}_h$</span> and <span>$\tilde{S}_h$</span> are automatically generated and used inside the multigrid symbol matrix.</p><h3 id="Grid-Transfer-Operators"><a class="docs-heading-anchor" href="#Grid-Transfer-Operators">Grid Transfer Operators</a><a id="Grid-Transfer-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-Transfer-Operators" title="Permalink"></a></h3><p>We consider grid transfer operators for p-type multigrid. The finite element operator for prolongation from the lower order coarse grid to the high order fine grid is given by </p><div>\[P_{ctof} = P_f^T P_e P_c\\
P_e = D_{scale} B_{ctof}\]</div><p>where <span>$B_{ctof}$</span> is a basis interpolation from the coarse basis to the fine basis, <span>$P_f$</span> is the fine grid element assembly operator, <span>$P_c$</span> is the coarse grid element assembly operator, and <span>$D_{scale}$</span> is a scaling operator to account for node multiplicity across element interfaces.</p><p>Restriction from the fine grid to the coarse grid is given by the transpose, <span>$R_{ftoc} = P_{ctof}^T$</span>.</p><p>Thus, the symbol of <span>$P_{ctof}$</span> is given by</p><div>\[\tilde{P}_{ctof} \left( \theta \right) = Q_f^T \left( \left( D_{scale} B_{ctof} \right) \odot \left[ e^{\imath \sum_d \left( \mathbf{x}_{i, f} - \mathbf{x}_{j, c} \right) \mathbf{\theta} / \mathbf{h}} \right] \right) Q_c\]</div><p>and <span>$\tilde{R}_{ftoc}$</span> is given by the analogous computation</p><div>\[\tilde{R}_{ftoc} \left( \theta \right) = Q_c^T \left( \left( D_{scale} B_{ctof} \right)^T \odot \left[ e^{\imath \sum_d \left( \mathbf{x}_{i, c} - \mathbf{x}_{j, f} \right) \mathbf{\theta} / \mathbf{h}} \right] \right) Q_f.\]</div><p>The grid transfer operators for h-multgrid can be represented in a similar fashion by representing the fine grid as consisting of macro-elements that consist of multiple micro elements of the same polynomial order as the coarse grid elements.</p><h3 id="Multigrid-Error-Propagation-Symbol"><a class="docs-heading-anchor" href="#Multigrid-Error-Propagation-Symbol">Multigrid Error Propagation Symbol</a><a id="Multigrid-Error-Propagation-Symbol-1"></a><a class="docs-heading-anchor-permalink" href="#Multigrid-Error-Propagation-Symbol" title="Permalink"></a></h3><p>Combining these elements, the symbol of the error propagation operator for p-multigrid is given by</p><div>\[\tilde{E}_{TMG} \left( \omega, \nu, \theta \right) = \tilde{S}_f \left( \omega, \nu, \theta \right) \left[ I - \tilde{P}_{ctof} \left( \theta \right) \tilde{A}_c^{-1} \left( \theta \right) \tilde{R}_{ftoc} \left( \theta \right) \tilde{A}_f \left( \theta \right) \right] \tilde{S}_f \left( \omega, \nu, \theta \right)\]</div><p>where <span>$\tilde{P}_{ctof}$</span> and <span>$\tilde{R}_{ftoc}$</span> are given above, <span>$\tilde{S}_f$</span> is given by the smoothing operator, and <span>$\tilde{A}_c$</span> and <span>$\tilde{A}_f$</span> are derived from the PDE being analyzed.</p><p>This can be extended to multi-level analysis by applying this analysis recursively, keeping in mind that <span>$\tilde{E}_{TMG}$</span> is the symbol of the multigrid error propagation operator. The symbol of the multigrid operator is computed by noting that <span>$E = I - M A$</span>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 19 May 2021 14:02">Wednesday 19 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
