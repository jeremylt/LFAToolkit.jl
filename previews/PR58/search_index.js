var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A. Brandt, Multi-level adaptive solutions to boundary-value problems, Math. Comp., 31(138) (1977), pp. 33-390.","category":"page"},{"location":"references/","page":"References","title":"References","text":"A. N. Brooks and T. J. R. Hughes Streamline upwind/Petrov–Galerkin formulations for convection dominated ﬂows with particular emphasis on the incompressible Navier–Stokes equations, Comput Meth Appl Mech Eng, 32 (1982), pp. 199-259.","category":"page"},{"location":"references/","page":"References","title":"References","text":"J. Brown, Efficient nonlinear solvers for nodal high-order finite elements in 3D, Journal of Scientific Computing, 45 (2010), pp. 48-63.","category":"page"},{"location":"references/","page":"References","title":"References","text":"M. Gutknecht and S. Röllin,  The Chebyshev iteration revisited, Parallel Computing, 28 (2002), pp. 263-283.","category":"page"},{"location":"references/","page":"References","title":"References","text":"N. Hale and L. N. Trefethen, New quadrature formulas from conformal maps, SIAM Journal on Numerical Analysis. Vol. 46, No. 2, (2008), pp. 930-948.","category":"page"},{"location":"references/","page":"References","title":"References","text":"T. J. R. Hughes and A. N. Brooks A multi-dimensional upwind scheme with no crosswind diﬀusion, In: Hughes TJR, editor. Finite element methods for convection dominated ﬂows, AMD-vol. 34. New York: ASME, (1979), pp. 19-35.","category":"page"},{"location":"references/","page":"References","title":"References","text":"T. Melvin, A. Staniforth and J. Thuburn, Dispersion analysis of the spectral element method, Q.J.R. Meteorol. Soc. 138, (2012), pp. 1934-1947.","category":"page"},{"location":"references/","page":"References","title":"References","text":"C. H. Whiting, K. E. Jansen and S. Dey, Hierarchical basis for stabilized finite element methods for compressible flows, Comput. Methods Appl. Mech. Engrg. 192, (2003), pp. 5167-5185.","category":"page"},{"location":"examples/linear_elasticity/#Linear-elasticity","page":"-","title":"Linear elasticity","text":"","category":"section"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"This is an example of a p-multigrid preconditioner with Chebyshev smoothing for the 3D linear elasticity problem.","category":"page"},{"location":"examples/linear_elasticity/#Problem-formulation","page":"-","title":"Problem formulation","text":"","category":"section"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"The strong form of the static balance of linear-momentum at finite strain is given by","category":"page"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"nabla cdot boldsymbolsigma + boldg = bold0","category":"page"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"where boldsymbolsigma and boldg are the stress and forcing functions, respectively.","category":"page"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"We have the weak form","category":"page"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"int_Omega nabla boldv  boldsymbolsigma - int_partial Omega v cdot left( boldsymbolsigma cdot hatboldn right) - int_Omega boldv cdot boldg = 0","category":"page"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"The constitutive law (stress-strain relationship) can be written as","category":"page"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"boldsymbolsigma = boldC  boldsymbolepsilon","category":"page"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"where boldsymbolepsilon is the infinitesimal strain tensor","category":"page"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"boldsymbolepsilon = frac12 left( nabla boldu + nabla boldu^T right)","category":"page"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"and the elasticity tensor boldC is given by","category":"page"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"boldC =\nbeginpmatrix\n   lambda + 2mu  lambda  lambda    \n   lambda  lambda + 2mu  lambda    \n   lambda  lambda  lambda + 2mu    \n      mu   \n       mu  \n        mu\n   endpmatrix","category":"page"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"lambda and mu are the Lamé parameters, given by","category":"page"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"lambda = fracE nuleft( 1 + nu right) left( 1 - 2 nu right) \nmu = fracE2 left( 1 + nu right)","category":"page"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"where E is the Young's modulus and nu is the Poisson's ratio for the materiel.","category":"page"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"For a full discussion of the formulation of the linear elasticity problem, see the libCEED documentation.","category":"page"},{"location":"examples/linear_elasticity/#LFAToolkit-code","page":"-","title":"LFAToolkit code","text":"","category":"section"},{"location":"examples/linear_elasticity/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex301_linear_elasticity.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"private/pc/chebyshev/#Preconditioner:-Chebyshev","page":"-","title":"Preconditioner: Chebyshev","text":"","category":"section"},{"location":"private/pc/chebyshev/","page":"-","title":"-","text":"LFAToolkit.getoperatordiagonalinverse(::Chebyshev)\nLFAToolkit.geteigenvalueestimates(::Chebyshev)","category":"page"},{"location":"private/pc/chebyshev/#LFAToolkit.getoperatordiagonalinverse-Tuple{Chebyshev}","page":"-","title":"LFAToolkit.getoperatordiagonalinverse","text":"getoperatordiagonalinverse(preconditioner)\n\nCompute or retrieve the inverse of the symbol matrix diagonal for a Chebyshev     preconditioner\n\nArguments:\n\npreconditioner:  preconditioner to compute diagonal inverse\n\nReturns:\n\nSymbol matrix diagonal inverse for the operator\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n# preconditioner\nchebyshev = Chebyshev(diffusion)\n\n# note: either syntax works\ndiagonalinverse = LFAToolkit.getoperatordiagonalinverse(chebyshev);\ndiagonalinverse = chebyshev.operatordiagonalinverse;\n\n# verify\n@assert diagonalinverse ≈ [6/7 0; 0 3/4]\n \n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/pc/chebyshev/#LFAToolkit.geteigenvalueestimates-Tuple{Chebyshev}","page":"-","title":"LFAToolkit.geteigenvalueestimates","text":"geteigenvalueestimates(preconditioner)\n\nCompute or retrieve the eigenvalue estimates for a Chebyshev preconditioner\n\nArguments:\n\npreconditioner:  preconditioner to compute eigenvalue estimates\n\nReturns:\n\nEigenvalue estimates for the operator\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n# preconditioner\nchebyshev = Chebyshev(diffusion)\n\n# estimate eigenvalues\neigenvalueestimates = LFAToolkit.geteigenvalueestimates(chebyshev);\n\n# verify\n@assert eigenvalueestimates ≈ [0, 15/7]\n \n# output\n\n\n\n\n\n\n","category":"method"},{"location":"public/mesh/#Rectangular-Mesh","page":"-","title":"Rectangular Mesh","text":"","category":"section"},{"location":"public/mesh/","page":"-","title":"-","text":"LFA is conducted on a infinite uniform grid. The mesh object allows the user to specify different scaling between the different dimensions of the mesh. This facilitates investigation of the smoothing and multigrid techniques on highly distorted meshes, such as boundary layer elements.","category":"page"},{"location":"public/mesh/","page":"-","title":"-","text":"Mesh1D\nMesh2D\nMesh3D","category":"page"},{"location":"public/mesh/#LFAToolkit.Mesh1D","page":"-","title":"LFAToolkit.Mesh1D","text":"Mesh1D(dx)\n\nOne dimensional regular background mesh\n\nArguments:\n\ndx:  deformation in x dimension\n\nReturns:\n\nOne dimensional mesh object\n\nExample:\n\n# generate 1D mesh\nmesh = Mesh1D(1.0);\n\n# verify\nprintln(mesh)\n\n# output\n1d mesh:\n    dx: 1.0\n\n\n\n\n\n","category":"type"},{"location":"public/mesh/#LFAToolkit.Mesh2D","page":"-","title":"LFAToolkit.Mesh2D","text":"Mesh2D(dx, dy)\n\nTwo dimensional regular background mesh\n\nArguments:\n\ndx:  deformation in x dimension\ndy:  deformation in y dimension\n\nReturns:\n\nTwo dimensional mesh object\n\nExample:\n\n# generate 2D mesh\nmesh = Mesh2D(1.0, 0.5);\n\n# verify\nprintln(mesh)\n\n# output\n2d mesh:\n    dx: 1.0\n    dy: 0.5\n\n\n\n\n\n","category":"type"},{"location":"public/mesh/#LFAToolkit.Mesh3D","page":"-","title":"LFAToolkit.Mesh3D","text":"Mesh3D(dx, dy, dz)\n\nThree dimensional regular background mesh\n\nArguments:\n\ndx:  deformation in x dimension\ndy:  deformation in y dimension\ndz:  deformation in z dimension\n\nReturns:\n\nThree dimensional mesh object\n\nExample:\n\n# generate 3D mesh\nmesh = Mesh3D(1.0, 0.5, 0.3);\n\n# verify\nprintln(mesh)\n\n# output\n3d mesh:\n    dx: 1.0\n    dy: 0.5\n    dz: 0.3\n\n\n\n\n\n","category":"type"},{"location":"public/pc/identity/#Preconditioner:-Identity","page":"-","title":"Preconditioner: Identity","text":"","category":"section"},{"location":"public/pc/identity/","page":"-","title":"-","text":"The identity preconditioner object allows investigation of multigrid methods without smoothers.","category":"page"},{"location":"public/pc/identity/#Documentation","page":"-","title":"Documentation","text":"","category":"section"},{"location":"public/pc/identity/","page":"-","title":"-","text":"IdentityPC\ncomputesymbols(::IdentityPC, ::Array, ::Array)","category":"page"},{"location":"public/pc/identity/#LFAToolkit.IdentityPC","page":"-","title":"LFAToolkit.IdentityPC","text":"IdentityPC()\n\nIdentity preconditioner to investigate multigrid without smoother\n\nReturns:\n\nIdentity preconditioner object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# preconditioner\nidentity = IdentityPC(mass);\n\n# verify\nprintln(identity)\n\n# output\nidentity preconditioner\n\n\n\n\n\n","category":"type"},{"location":"public/pc/identity/#LFAToolkit.computesymbols-Tuple{IdentityPC, Array, Array}","page":"-","title":"LFAToolkit.computesymbols","text":"computesymbols(preconditioner, ω, θ)\n\nCompute or retrieve the symbol matrix for a identity preconditioned operator\n\nArguments:\n\npreconditioner:  Identity preconditioner to compute symbol matrix for\nω:               smoothing weighting factor array\nθ:               Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the identity preconditioner (I)\n\nExample:\n\nusing LinearAlgebra\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# preconditioner\nidentity = IdentityPC(mass);\n\n# compute symbols\nA = computesymbols(identity, [], []);\n\n# verify\n@assert A ≈ I\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/basis/#Finite-Element-Basis","page":"-","title":"Finite Element Basis","text":"","category":"section"},{"location":"private/basis/","page":"-","title":"-","text":"LFAToolkit.AbstractBasis\nLFAToolkit.transformquadrature\nLFAToolkit.sausage_transformation\nLFAToolkit.kosloff_talezer_transformation\nLFAToolkit.hale_trefethen_strip_transformation\nLFAToolkit.TensorMacroElementBasisFrom1D\nLFAToolkit.TensorHProlongationBasis\nLFAToolkit.buildinterpolationandgradient\nLFAToolkit.getnumbernodes\nLFAToolkit.getnodes\nLFAToolkit.getnumberquadraturepoints\nLFAToolkit.getquadraturepoints\nLFAToolkit.getquadratureweights\nLFAToolkit.getinterpolation\nLFAToolkit.getgradient\nLFAToolkit.getnumbermodes\nLFAToolkit.getmodemap\nLFAToolkit.getnumberelements\nLFAToolkit.getdiagonal\nLFAToolkit.getdXdxgradient\nLFAToolkit.getdxdXquadratureweights\nLFAToolkit.getprimalnodes(::TensorBasis)\nLFAToolkit.getinterfacenodes(::TensorBasis)","category":"page"},{"location":"private/basis/#LFAToolkit.AbstractBasis","page":"-","title":"LFAToolkit.AbstractBasis","text":"Finite element basis for function spaces and test spaces\n\n\n\n\n\n","category":"type"},{"location":"private/basis/#LFAToolkit.transformquadrature","page":"-","title":"LFAToolkit.transformquadrature","text":"transformquadrature(points, weights, mapping)\n\nArguments:\n\npoints:   array of quadrature points\nweights:  optional array of weights to transform\nmapping:  choice of conformal map\n\nReturns:\n\nTransformed quadrature by applying a smooth mapping = (g, gprime) from the original domain.\n\nExample:\n\nusing FastGaussQuadrature;\n\n# generate transformed quadrature points, weights with choice of conformal map\npoints, weights = gausslegendre(5);\nmapping = sausage_transformation(9);\nmappedpoints, mappedweights = transformquadrature(points, weights, mapping);\n\n# verify:\nweightsum = sum(mappedweights);\n@assert weightsum ≈ 2.0\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.sausage_transformation","page":"-","title":"LFAToolkit.sausage_transformation","text":"sausage_transformation(d)\n\nArguments:\n\nd:  polynomial degree of truncated Taylor series expansion of arcsin(s).\n\nReturns:\n\nConformal mapping of Gauss ellipses to sausage_transformations using a truncated Taylor expansion of arcsin(s). See Figure 4.1 of Hale and Trefethen (2008).\n\nExample:\n\n# sausage_transformation conformal map\ng, gprime = LFAToolkit.sausage_transformation(9);\n\n# verify\n@assert g.(LinRange(-1,1,5)) ≈ [-0.9999999999999999, -0.39765215163451934, 0.0, 0.39765215163451934, 0.9999999999999999]\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.kosloff_talezer_transformation","page":"-","title":"LFAToolkit.kosloff_talezer_transformation","text":"kosloff_talezer_transformation(α)\n\nArguments:\n\nα:  polynomial degree of truncated Taylor series expansion of arcsin(s).\n\nReturns:\n\nThe Kosloff and Tal-Ezer conformal map derived from the inverse sine function.\n\nExample:\n\n# kosloff_talezer_transformation conformal map\ng, gprime = LFAToolkit.kosloff_talezer_transformation(0.95);\n\n# verify\n@assert g.(LinRange(-1,1,5)) ≈ [-1.0, -0.39494881426787537, 0.0, 0.39494881426787537, 1.0]\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.hale_trefethen_strip_transformation","page":"-","title":"LFAToolkit.hale_trefethen_strip_transformation","text":"hale_trefethen_strip_transformation(ρ)\n\nArguments:\n\nρ:  sum of the semiminor and semimajor axis\n\nReturns:\n\nThe Hale and Trefethen strip transformation\n\nExample:\n\n# hale_trefethen_strip_transformation conformal map\ng, gprime = hale_trefethen_strip_transformation(1.4);\n\n# verify\n@assert g.(LinRange(-1,1,5)) ≈ [-1.0, -0.36812132798370184, 0.0, 0.36812132798370184, 1.0]\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.TensorMacroElementBasisFrom1D","page":"-","title":"LFAToolkit.TensorMacroElementBasisFrom1D","text":"TensorMacroElementBasisFrom1D(\n    numbernodes1d,\n    numberquadraturepoints1d,\n    numbercomponents,\n    dimension,\n    numberelements1d,\n    basis1dmicro,\n    overlapquadraturepoints = false,\n)\n\nTensor product macro-element basis from 1d single element tensor product basis\n\nArguments:\n\nnumbernodes1d:             number of basis nodes in 1 dimension\nnumberquadraturepoints1d:  number of quadrature points in 1 dimension\nnumbercomponents:          number of components\ndimension:                 dimension of basis\nnumberelements1d:          number of elements in macro-element\nbasis1dmicro:              1d micro element basis to replicate\n\nKeyword Arguments:\n\noverlapquadraturepoints:  Overlap quadrature points between elements, for prolongation                                 default: false\n\nReturns:\n\nTensor product macro-element basis object\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.TensorHProlongationBasis","page":"-","title":"LFAToolkit.TensorHProlongationBasis","text":"TensorHProlongationBasis(\n    coarsenodes1d,\n    finenodes1d,\n    numbercomponents,\n    dimension,\n    numberfineelements1d,\n)\n\nTensor product h-prolongation basis\n\nArguments:\n\ncoarsenodes1d:         coarse grid node coordinates in 1 dimension\nfinenodes1d:           fine grid node coordinates in 1 dimension\nnumbercomponents:      number of components\ndimension:             dimension of basis\nnumberfineelements1d:  number of fine grid elements\n\nReturns:\n\nH1 Lagrange tensor product h-prolongation basis object\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.buildinterpolationandgradient","page":"-","title":"LFAToolkit.buildinterpolationandgradient","text":"buildinterpolationandgradient(\n    nodes,\n    quadraturepoints,\n)\n\nBuild one dimensional interpolation and gradient matrices, from Fornberg 1998\n\nArguments:\n\nnodes:             1d basis nodes\nquadraturepoints:  1d basis quadrature points\n\nReturns:\n\nOne dimensional interpolation and gradient matrices\n\nExample:\n\nusing FastGaussQuadrature\n\n# get nodes, quadrature points, and weights\nnumbernodes = 3;\nnumberquadraturepoints = 4;\nnodes, = gausslobatto(numbernodes);\nquadraturepoints, quadratureweights1d = gausslegendre(numberquadraturepoints);\n\n# build interpolation, gradient matrices\ninterpolation, gradient = LFAToolkit.buildinterpolationandgradient(nodes, quadraturepoints);\n\n# verify\nfor i in 1:numberquadraturepoints\n    total = sum(interpolation[i, :]);\n    @assert total ≈ 1.0\n\n    total = sum(gradient[i, :]);\n    @assert abs(total) < 1e-14\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getnumbernodes","page":"-","title":"LFAToolkit.getnumbernodes","text":"getnumbernodes(basis)\n\nGet the number of nodes for the basis\n\nArguments:\n\nbasis:  basis to compute number of nodes\n\nReturns:\n\nInteger number of basis nodes\n\nExample:\n\n# get number of nodes for basis\nbasis = TensorH1LagrangeBasis(4, 3, 2, 2);\n\n# note: either syntax works\nnumbernodes = LFAToolkit.getnumbernodes(basis);\nnumbernodes = basis.numbernodes;\n\n# verify\n@assert numbernodes == 4^2\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getnodes","page":"-","title":"LFAToolkit.getnodes","text":"getnodes(basis)\n\nGet nodes for basis\n\nReturns:\n\nBasis nodes array\n\nArguments:\n\nbasis:  basis to compute nodes\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get basis quadrature weights\n    basis = TensorH1LagrangeBasis(4, 3, 2, dimension);\n\n    # note: either syntax works\n    nodes = LFAToolkit.getnodes(basis);\n    nodes = basis.nodes;\n\n    # verify\n    truenodes1d = [-1, -√(1/5), √(1/5), 1];\n    truenodes = [];\n    if dimension == 1\n        truenodes = truenodes1d;\n    elseif dimension == 2\n        truenodes =\n            transpose(hcat([[[x, y] for x in truenodes1d, y in truenodes1d]...]...));\n    elseif dimension == 3\n        truenodes = transpose(hcat([[\n            [x, y, z] for x in truenodes1d, y in truenodes1d, z in truenodes1d\n        ]...]...));\n    end\n\n    @assert truenodes ≈ nodes\nend\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getnumberquadraturepoints","page":"-","title":"LFAToolkit.getnumberquadraturepoints","text":"getnumberquadraturepoints(basis)\n\nGet the number of quadrature points for the basis\n\nArguments:\n\nbasis:  basis to compute number of quadrature points\n\nReturns:\n\nInteger number of basis quadrature points\n\nExample:\n\n# get number of quadrature points for basis\nbasis = TensorH1LagrangeBasis(4, 3, 2, 2);\n\n# note: either syntax works\nnumberquadraturepoints = LFAToolkit.getnumberquadraturepoints(basis);\nnumberquadraturepoints = basis.numberquadraturepoints;\n    \n# verify\n@assert numberquadraturepoints == 3^2\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getquadraturepoints","page":"-","title":"LFAToolkit.getquadraturepoints","text":"getquadraturepoints(basis)\n\nGet quadrature points for basis\n\nReturns:\n\nBasis quadrature points array\n\nArguments:\n\nbasis: basis to compute quadrature points\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get basis quadrature weights\n    basis = TensorH1LagrangeBasis(4, 3, 2, dimension);\n\n    # note: either syntax works\n    quadraturepoints = LFAToolkit.getquadraturepoints(basis);\n    quadraturepoints = basis.quadraturepoints;\n\n    # verify\n    truequadraturepoints1d = [-√(3/5), 0, √(3/5)];\n    truequadraturepoints = [];\n    if dimension == 1\n        truequadraturepoints = truequadraturepoints1d;\n    elseif dimension == 2\n        truequadraturepoints = transpose(hcat([[\n            [x, y] for x in truequadraturepoints1d, y in truequadraturepoints1d\n        ]...]...));\n    elseif dimension == 3\n        truequadraturepoints = transpose(hcat([[\n            [x, y, z]\n            for\n            x in truequadraturepoints1d,\n            y in truequadraturepoints1d, z in truequadraturepoints1d\n        ]...]...));\n    end\n\n    @assert truequadraturepoints ≈ quadraturepoints\nend\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getquadratureweights","page":"-","title":"LFAToolkit.getquadratureweights","text":"getquadratureweights(basis)\n\nGet full quadrature weights vector for basis\n\nReturns:\n\nBasis quadrature weights vector\n\nArguments:\n\nbasis:  basis to compute quadrature weights\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get basis quadrature weights\n    basis = TensorH1LagrangeBasis(4, 3, 2, dimension);\n\n    # note: either syntax works\n    quadratureweights = LFAToolkit.getquadratureweights(basis);\n    quadratureweights = basis.quadratureweights;\n\n    # verify\n    trueweights1d = [5/9, 8/9, 5/9];\n    trueweights = [];\n    if dimension == 1\n        trueweights = trueweights1d;\n    elseif dimension == 2\n        trueweights = kron(trueweights1d, trueweights1d);\n    elseif dimension == 3\n        trueweights = kron(trueweights1d, trueweights1d, trueweights1d);\n    end\n\n    @assert trueweights ≈ quadratureweights\nend\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getinterpolation","page":"-","title":"LFAToolkit.getinterpolation","text":"getinterpolation(basis)\n\nGet full interpolation matrix for basis\n\nArguments:\n\nbasis:  basis to compute interpolation matrix\n\nReturns:\n\nBasis interpolation matrix\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get basis interpolation matrix\n    basis = TensorH1LagrangeBasis(4, 3, 2, dimension);\n\n    # note: either syntax works\n    interpolation = LFAToolkit.getinterpolation(basis);\n    interpolation = basis.interpolation;\n\n    # verify\n    for i in 1:3^dimension\n        total = sum(interpolation[i, :]);\n        @assert total ≈ 1.0\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getgradient","page":"-","title":"LFAToolkit.getgradient","text":"getgradient(basis)\n\nGet full gradient matrix for basis\n\nArguments:\n\nbasis:  basis to compute gradient matrix\n\nReturns:\n\nBasis gradient matrix\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get basis gradient matrix\n    basis = TensorH1LagrangeBasis(4, 3, 2, dimension);\n\n    # note: either syntax works\n    gradient = LFAToolkit.getgradient(basis);\n    gradient = basis.gradient;\n\n    # verify\n    for i in 1:dimension*3^dimension\n        total = sum(gradient[i, :]);\n        @assert abs(total) < 1e-14\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getnumbermodes","page":"-","title":"LFAToolkit.getnumbermodes","text":"getnumbermodes(basis)\n\nGet number of modes for basis\n\nArguments:\n\nbasis:  basis to compute number of modes\n\nReturns:\n\nNumber of modes for basis\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get number of basis modes\n    basis = TensorH1LagrangeBasis(4, 3, 2, dimension);\n\n    # note: either syntax works\n    numbermodes = LFAToolkit.getnumbermodes(basis);\n    numbermodes = basis.numbermodes;\n\n    # verify\n    @assert numbermodes == 2*3^dimension\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getmodemap","page":"-","title":"LFAToolkit.getmodemap","text":"getmodemap(basis)\n\nGet mode mapping vector for basis\n\nArguments:\n\nbasis:  basis to compute mode map vector\n\nReturns:\n\nBasis mode map vector\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get mode map vector\n    basis = TensorH1LagrangeBasis(4, 3, 1, dimension);\n\n    # note: either syntax works\n    modemap = LFAToolkit.getmodemap(basis);\n    modemap = basis.modemap;\n\n    # verify\n    truemodemap1d = [1, 2, 3, 1];\n    truemodemap = [];\n    if dimension == 1\n        truemodemap = truemodemap1d;\n    elseif dimension == 2\n        truemodemap = [[\n            i + (j - 1)*3 for i in truemodemap1d, j in truemodemap1d\n        ]...];\n    elseif dimension == 3\n        truemodemap = [[\n            i +\n            (j - 1)*3 +\n            (k - 1)*3^2\n            for i in truemodemap1d, j in truemodemap1d, k in truemodemap1d\n        ]...];\n    end\n\n    @assert truemodemap == modemap\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getnumberelements","page":"-","title":"LFAToolkit.getnumberelements","text":"getnumberelements(basis)\n\nGet the number of elements for the basis\n\nArguments:\n\nbasis:  basis to compute number of micro-elements\n\nReturns:\n\nInteger number of basis micro-elements\n\nExample:\n\n# get number of nodes for basis\nbasis = TensorH1LagrangeMacroBasis(4, 4, 1, 2, 2);\n\n# note: either syntax works\nnumbernodes = LFAToolkit.getnumberelements(basis);\nnumbernodes = basis.numberelements;\n\n# verify\n@assert numbernodes == 2^2\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getdiagonal","page":"-","title":"LFAToolkit.getdiagonal","text":"getdiagonal(operator)\n\nCompute or retrieve the symbol matrix diagonal for an operator\n\nArguments:\n\noperator:  operator to compute diagonal\n\nReturns:\n\nSymbol matrix diagonal for the operator\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n# note: either syntax works\ndiagonal = LFAToolkit.getdiagonal(diffusion);\ndiagonal = diffusion.diagonal;\n\n# verify\n@assert diagonal ≈ [7/6 0; 0 4/3]\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getdXdxgradient","page":"-","title":"LFAToolkit.getdXdxgradient","text":"getdXdxgradient(basis, mesh)\n\nGet gradient adjusted for mesh stretching\n\nArguments:\n\nbasis:  basis to compute gradient\nmesh:   mesh to compute gradient\n\nReturns:\n\ngradient matrix multiplied by change of coordinates adjoint\n\nExample:\n\nfor dimension = 1:3\n    # mesh\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(2.0)\n    elseif dimension == 2\n        mesh = Mesh2D(2.0, 3.0)\n    elseif dimension == 3\n        mesh = Mesh3D(2.0, 3.0, 4.0)\n    end\n\n    # basis\n    basis = TensorH1LagrangeBasis(4, 3, 1, dimension);\n\n    # get gradient on mesh\n    gradient = LFAToolkit.getdXdxgradient(basis, mesh);\n\n    # verify\n    nodes = basis.nodes;\n    linearfunction = [];\n    truegradient = [];\n    if dimension == 1\n        linearfunction = nodes;\n        truegradient = [1/2*ones(basis.numberquadraturepoints)...]\n    elseif dimension == 2\n        linearfunction = (nodes[:, 1] + nodes[:, 2]);\n        truegradient = [\n            1/2*ones(basis.numberquadraturepoints)...\n            1/3*ones(basis.numberquadraturepoints)...\n        ]\n    elseif dimension == 3\n        linearfunction = (nodes[:, 1] + nodes[:, 2] + nodes[:, 3]);\n        truegradient = [\n            1/2*ones(basis.numberquadraturepoints)...\n            1/3*ones(basis.numberquadraturepoints)...\n            1/4*ones(basis.numberquadraturepoints)...\n        ]\n    end\n\n    @assert gradient*linearfunction ≈ truegradient\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getdxdXquadratureweights","page":"-","title":"LFAToolkit.getdxdXquadratureweights","text":"getdxdXquadratureweights(basis, mesh)\n\nGet quadrature weights adjusted for mesh stretching\n\nArguments:\n\nbasis:  basis to compute quadratureweights\nmesh:   mesh to compute quadratureweights\n\nReturns:\n\nquadrature weights multiplied by change of coordinates adjoint\n\nExample:\n\nmesh = Mesh1D(2.0)\n\n# basis\nbasis = TensorH1LagrangeBasis(4, 3, 1, 1);\n\n# get gradient on mesh\nweights = LFAToolkit.getdxdXquadratureweights(basis, mesh);\n\n# verify\n@assert basis.quadratureweights * mesh.volume / basis.volume ≈ weights\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getprimalnodes-Tuple{TensorBasis}","page":"-","title":"LFAToolkit.getprimalnodes","text":"getprimalnodes(basis)\n\nGet primal nodes for basis\n\nArguments:\n\nbasis:  basis to compute primal nodes\n\nReturns:\n\nBasis primal nodes vector\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get mode map vector\n    p = 4\n    basis = TensorH1LagrangeBasis(p, p, 1, dimension);\n\n    # note: either syntax works\n    primalnodes = LFAToolkit.getprimalnodes(basis);\n    primalnodes = basis.primalnodes;\n\n    # verify\n    trueprimalnodes = []\n    if dimension == 1\n        trueprimalnodes = [1, p];\n    elseif dimension == 2\n        trueprimalnodes = [1, p, p^2-p+1, p^2]\n    elseif dimension == 3\n        trueprimalnodes = [1, p, p^2-p+1, p^2, p^3-p^2+1, p^3-p^2+p, p^3-p+1, p^3]\n    end\n\n    @assert trueprimalnodes == primalnodes\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/basis/#LFAToolkit.getinterfacenodes-Tuple{TensorBasis}","page":"-","title":"LFAToolkit.getinterfacenodes","text":"getinterfacenodes(basis)\n\nGet interface nodes for basis\n\nArguments:\n\nbasis:  basis to compute primal nodes\n\nReturns:\n\nBasis primal nodes vector\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get mode map vector\n    p = 4\n    basis = TensorH1LagrangeBasis(p, p, 1, dimension);\n\n    # note: either syntax works\n    interfacenodes = LFAToolkit.getinterfacenodes(basis);\n    interfacenodes = basis.interfacenodes;\n\n    # verify\n    trueinterfacenodes = []\n    if dimension == 1\n        trueinterfacenodes = [1, p];\n    elseif dimension == 2\n        trueinterfacenodes = [1:p..., p^2-p+1:p^2...]\n        for i = 1:p-2\n            push!(trueinterfacenodes, i*p+1)\n            push!(trueinterfacenodes, (i+1)*p)\n        end\n    elseif dimension == 3\n        trueinterfacenodes = [1:p^2..., p^3-p^2+1:p^3...]\n        for i = 1:p-2\n            push!(trueinterfacenodes, i*p^2+1:i*p^2+p...)\n            push!(trueinterfacenodes, (i+1)*p^2-p+1:(i+1)*p^2...)\n            push!(trueinterfacenodes, i*p^2+p+1:p:(i+1)*p^2-2*p+1...)\n            push!(trueinterfacenodes, i*p^2+2*p:p:(i+1)*p^2-p...)\n        end\n    end\n    trueinterfacenodes = sort(trueinterfacenodes)\n\n    @assert trueinterfacenodes == interfacenodes\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"examples/advection/#Advection-operator","page":"-","title":"Advection operator","text":"","category":"section"},{"location":"examples/advection/","page":"-","title":"-","text":"This is an example of the 1D scalar advection problem.","category":"page"},{"location":"examples/advection/#Problem-formulation","page":"-","title":"Problem formulation","text":"","category":"section"},{"location":"examples/advection/","page":"-","title":"-","text":"The advection problem is given by","category":"page"},{"location":"examples/advection/","page":"-","title":"-","text":"dfracpartial upartial t + c dfracpartial upartial x = 0","category":"page"},{"location":"examples/advection/","page":"-","title":"-","text":"where u = u(xt) and c is its associated phase speed.","category":"page"},{"location":"examples/advection/","page":"-","title":"-","text":"The weak form is given by","category":"page"},{"location":"examples/advection/","page":"-","title":"-","text":"int_Omega v left(dfracpartial upartial t right) dV - int_Omega c u left( dfracpartial vpartial x right) dV = 0 forall v in V","category":"page"},{"location":"examples/advection/","page":"-","title":"-","text":"for an appropriate test space V subseteq H^1 left( Omega right) on the domain. In this weak formulation, boundary terms have been omitted, as they are not present on the infinite grid for Local Fourier Analysis.","category":"page"},{"location":"examples/advection/#LFAToolkit-code","page":"-","title":"LFAToolkit code","text":"","category":"section"},{"location":"examples/advection/","page":"-","title":"-","text":"The advection operator is a classical test case to see dispersion spectrum inside LFAToolkit. Here we show the advection operator on a non-polynomial basis derived from the Hale-Trefethen strip transformation applied to a H1 Lagrange basis.","category":"page"},{"location":"examples/advection/","page":"-","title":"-","text":"For understanding about nonpolynomial bases, see paper Hale and Trefethen (2008) New quadrature formulas from conformal maps. https://doi.org/10.1137/07068607X","category":"page"},{"location":"examples/advection/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex010_advection.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"private/#Private-API","page":"Private API","title":"Private API","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"This section documents the private API of the LFAToolkit.","category":"page"},{"location":"private/#Contents","page":"Private API","title":"Contents","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"Pages = [\n    \"private/mesh.md\",\n    \"private/basis.md\",\n    \"private/operator.md\",\n    \"private/pc/base.md\",\n    \"private/pc/jacobi.md\",\n    \"private/pc/chebyshev.md\",\n    \"private/pc/multigrid.md\",\n    \"private/pc/bddc.md\",\n]","category":"page"},{"location":"public/utilities/#Utilities","page":"-","title":"Utilities","text":"","category":"section"},{"location":"public/utilities/","page":"-","title":"-","text":"These functions are utilities for common analysis.","category":"page"},{"location":"public/utilities/","page":"-","title":"-","text":"computesymbolsoverrange(::Operator, ::Int)\ncomputesymbolsoverrange(::AbstractPreconditioner, ::Array, ::Int)\ncomputesymbolsoverrange(::Multigrid, ::Array, ::Array, ::Int)","category":"page"},{"location":"public/utilities/#LFAToolkit.computesymbolsoverrange-Tuple{Operator, Int64}","page":"-","title":"LFAToolkit.computesymbolsoverrange","text":"computesymbolsoverrange(operator, numbersteps1d; mass = nothing, θ_min = -π/2, θ_band = 2π)\n\nCompute the eigenvalues and eigenvectors of the symbol matrix for an operator over   a range of θ from -π/2 to 3π/2\n\nArguments:\n\noperator:       Finite element operator to compute symbol matrices for\nnumbersteps1d:  Number of values of θ to sample in each dimension                       Note: numbersteps1d^dimension symbol matrices will be computed\n\nKeyword Arguments:\n\nmass:   Mass operator to invert for comparison to analytic solution,               default: nothing\nθ_min:  Bottom of range of θ, shifts range to [θmin, θmin + 2π],               default: -π / 2\nθ_band: θmax = θmin + θ_band               default: 2π\n\nReturns:\n\nValues of θ sampled\nEigenvalues of symbol matrix at θ sampled\nEigenvectors of symbol matrix at θ sampled\n\nExamples:\n\nusing LFAToolkit;\n\nnumbersteps1d = 5;\n\nfor dimension in 1:3\n    # setup\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(1.0);\n    elseif dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    diffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n    # compute symbols\n    (_, eigenvalues, _) = computesymbolsoverrange(diffusion, numbersteps1d);\n\n    # verify\n    eigenvalues = real(eigenvalues);\n    if dimension == 1\n        @assert minimum(eigenvalues[4, :]) ≈ 1\n        @assert maximum(eigenvalues[4, :]) ≈ 4/3\n    elseif dimension == 2\n        @assert minimum(eigenvalues[19, :]) ≈ 2/3\n        @assert maximum(eigenvalues[19, :]) ≈ 64/45\n    elseif dimension == 3\n        @assert minimum(eigenvalues[94, :]) ≈ 1/3\n        @assert maximum(eigenvalues[94, :]) ≈ 256/225\n    end\nend\n\n# output\n\n\nusing LFAToolkit;\n\n# setup\nnumbersteps1d = 3;\nmesh = Mesh2D(0.5, 0.5);\np = 6;\n\n# operators\nmass = GalleryOperator(\"mass\", p + 1, p + 1, mesh);\ndiffusion = GalleryOperator(\"diffusion\", p + 1, p + 1, mesh);\n\n# compute symbols\n(_, eigenvalues, _) = computesymbolsoverrange(\n    diffusion,\n    numbersteps1d;\n    mass = mass,\n    θ_min = -π\n);\neigenvalues = real(eigenvalues);\n\n@assert minimum(eigenvalues[2, :]) ≈ π^2\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"public/utilities/#LFAToolkit.computesymbolsoverrange-Tuple{AbstractPreconditioner, Array, Int64}","page":"-","title":"LFAToolkit.computesymbolsoverrange","text":"computesymbolsoverrange(preconditioner, ω, numbersteps1d; mass=nothing, θ_min=-π/2)\n\nCompute the eigenvalues and eigenvectors of the symbol matrix for a preconditioned   operator over a range of θ from -π/2 to 3π/2\n\nArguments:\n\npreconditioner:  Preconditioner to compute symbol matries for\nω:               Smoothing parameter array\nnumbersteps1d:   Number of values of θ to sample in each dimension                        Note: numbersteps1d^dimension symbol matrices will be computed\n\nKeyword Arguments:\n\nmass:   Mass operator to invert for comparison to analytic solution,               default: nothing\nθ_min:  Bottom of range of θ, shifts range to [θmin, θmin + 2π],               default: -π / 2\n\nReturns:\n\nValues of θ sampled\nEigenvalues of symbol matrix at θ sampled\nEigenvectors of symbol matrix at θ sampled\n\nExample:\n\nusing LFAToolkit;\n\nnumbersteps1d = 5;\n\nfor dimension in 1:3\n    # setup\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(1.0);\n    elseif dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    diffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n    # preconditioner\n    chebyshev = Chebyshev(diffusion);\n\n    # compute symbols\n    (_, eigenvalues, _) = computesymbolsoverrange(chebyshev, [1], numbersteps1d);\n\n    # verify\n    eigenvalues = real(eigenvalues);\n    if dimension == 1\n        @assert minimum(eigenvalues[4, :]) ≈ 0.15151515151515105\n        @assert maximum(eigenvalues[4, :]) ≈ 0.27272727272727226\n    elseif dimension == 2\n        @assert minimum(eigenvalues[19, :]) ≈ -0.25495098334134725\n        @assert maximum(eigenvalues[19, :]) ≈ -0.17128758445192374\n    elseif dimension == 3\n        @assert minimum(eigenvalues[94, :]) ≈ -0.8181818181818181\n        @assert maximum(eigenvalues[94, :]) ≈ -0.357575757575757\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"public/utilities/#LFAToolkit.computesymbolsoverrange-Tuple{Multigrid, Array, Array, Int64}","page":"-","title":"LFAToolkit.computesymbolsoverrange","text":"computesymbolsoverrange(multigrid, p, v, numbersteps1d; mass=nothing, θ_min=-π/2)\n\nCompute the eigenvalues and eigenvectors of the symbol matrix for a multigrid   preconditioned operator over a range of θ from -π/2 to 3π/2\n\nArguments:\n\nmultigrid:      Preconditioner to compute symbol matries for\np:              Smoothing parameter array\nv:              Pre and post smooths iteration count array, 0 indicates no pre or post smoothing\nnumbersteps1d:  Number of values of θ to sample in each dimension                      Note: numbersteps1d^dimension symbol matrices will be computed\n\nKeyword Arguments:\n\nmass:   Mass operator to invert for comparison to analytic solution,               default: nothing\nθ_min:  Bottom of range of θ, shifts range to [θmin, θmin + 2π],               default: -π / 2\n\nReturns:\n\nValues of θ sampled\nEigenvalues of symbol matrix at θ sampled\nEigenvectors of symbol matrix at θ sampled\n\nExample:\n\nusing LFAToolkit;\n\nnumbersteps1d = 5;\n\nusing LinearAlgebra\n\nfor dimension in 1:3\n    # setup\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(1.0);\n    elseif dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    ctofbasis = TensorH1LagrangeBasis(3, 5, 1, dimension; collocatedquadrature=true);\n\n    # operators\n    finediffusion = GalleryOperator(\"diffusion\", 5, 5, mesh);\n    coarsediffusion = GalleryOperator(\"diffusion\", 3, 5, mesh);\n\n    # smoother\n    jacobi = Jacobi(finediffusion);\n\n    # preconditioner\n    multigrid = PMultigrid(finediffusion, coarsediffusion, jacobi, [ctofbasis]);\n\n    # compute symbols\n    (_, eigenvalues, _) = computesymbolsoverrange(multigrid, [1.0], [1, 1], numbersteps1d);\n\n    # verify\n    eigenvalues = real(eigenvalues)\n    if dimension == 1\n       @assert maximum(eigenvalues[4, :]) ≈ 0.64\n    elseif dimension == 2\n       @assert maximum(eigenvalues[19, :]) ≈ 0.9082562365654528\n    elseif dimension == 3\n       @assert maximum(eigenvalues[94, :]) ≈ 1.4359882222222669\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"examples/advection_supg/#Streamline-Upwind/Petrov-Galerkin-(SUPG)-advection-operator","page":"-","title":"Streamline-Upwind/Petrov-Galerkin (SUPG) advection operator","text":"","category":"section"},{"location":"examples/advection_supg/","page":"-","title":"-","text":"This is an example of the 1D scalar SUPG advection problem.","category":"page"},{"location":"examples/advection_supg/#Problem-formulation","page":"-","title":"Problem formulation","text":"","category":"section"},{"location":"examples/advection_supg/","page":"-","title":"-","text":"The advection problem is given by","category":"page"},{"location":"examples/advection_supg/","page":"-","title":"-","text":"dfracpartial upartial t + c dfracpartial upartial x = 0","category":"page"},{"location":"examples/advection_supg/","page":"-","title":"-","text":"where u = u(xt) and c is its associated phase speed.","category":"page"},{"location":"examples/advection_supg/","page":"-","title":"-","text":"The SUPG advection weak form is given by","category":"page"},{"location":"examples/advection_supg/","page":"-","title":"-","text":"int_Omega v left(dfracpartial upartial t right) dV - int_Omega dfracpartial vpartial x left(c u - c τ left( dfracpartial upartial t + c dfracpartial upartial x right) right) dV = 0 forall v in V","category":"page"},{"location":"examples/advection_supg/","page":"-","title":"-","text":"for an appropriate test space V subseteq H^1 left( Omega right) on the domain. In this weak formulation, boundary terms have been omitted, as they are not present on the infinite grid for Local Fourier Analysis. The SUPG stabilization is controlled by the parameter τ, where τ = 0 gives the classical Galerkin formulation and τ = dfrach2 gives a nodally exact solution to the steady advection equation with source when using linear elements (this can be extended to advection-diffusion with a further scaling that depends on the cell Péclet number).","category":"page"},{"location":"examples/advection_supg/#LFAToolkit-code","page":"-","title":"LFAToolkit code","text":"","category":"section"},{"location":"examples/advection_supg/","page":"-","title":"-","text":"The symbol of the continuous advection operator u_t + c u_x = 0 applied to the Fourier mode e^itheta x is itheta. The finite element discretization yields M u_t + A u = 0, and thus we are interested in the symbol of -M^-1 A. One may compare the continuous spectrum with the discrete symbol, which is necessarily periodic on -pi pi), to understand the behavior for high wave numbers, including the high frequencies that will limit stable time steps. To understand dispersion within the resolved frequencies, we instead plot the phase speed lambdatheta, which should be very close to c through the resolved frequencies. Here we show the SUPG advection operator on H^1 Lagrange basis.","category":"page"},{"location":"examples/advection_supg/","page":"-","title":"-","text":"For understanding about SUPG in this work, see papers by Hughes TJR, Brooks AN (1979, 1982) and C.H. Whiting A multi-dimensional upwind scheme with no crosswind diﬀusion. In: Hughes TJR, editor. Finite element methods for convection dominated ﬂows, AMD-vol. 34. New York: ASME, (1979), pp. 19-35. Streamline upwind/Petrov–Galerkin formulations for convection dominated ﬂows with particular emphasis on the incompressible Navier–Stokes equations. Comput Meth Appl Mech Eng, 32 (1982), pp. 199-259. Hierarchical basis for stabilized finite element methods for compressible flows. Comput. Methods Appl. Mech. Engrg. 192, (2003), pp. 5167-5185.","category":"page"},{"location":"examples/advection_supg/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex011_advection_supg.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/multigrid/#Preconditioner:-Multigrid","page":"-","title":"Preconditioner: Multigrid","text":"","category":"section"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"LFAToolkit supports both p-multigrid and h-multigrid.","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"MultigridType.MgridType","category":"page"},{"location":"public/pc/multigrid/#LFAToolkit.MultigridType.MgridType","page":"-","title":"LFAToolkit.MultigridType.MgridType","text":"Multigrid types\n\nTypes:\n\npmultigrid:  p-multigrid\nhmultigrid:  h-multigrid\n\nExample:\n\nLFAToolkit.MultigridType.MgridType\n\n# output\nEnum LFAToolkit.MultigridType.MgridType:\npmultigrid = 0\nhmultigrid = 1\n\n\n\n\n\n","category":"type"},{"location":"public/pc/multigrid/#P-Multigrid","page":"-","title":"P-Multigrid","text":"","category":"section"},{"location":"public/pc/multigrid/#Example","page":"-","title":"Example","text":"","category":"section"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"This is an example of a simple p-multigrid preconditioner.","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex201_pmultigrid.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"Example plot for the symbol of p-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"This is an example of a multilevel p-multigrid preconditioner.","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex202_pmultigrid_multilevel.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"Example plot for the symbol of multilevel p-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"public/pc/multigrid/#Documentation","page":"-","title":"Documentation","text":"","category":"section"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"PMultigrid\ncomputesymbols(::Multigrid, ::Array, ::Array{Int}, ::Array)","category":"page"},{"location":"public/pc/multigrid/#LFAToolkit.PMultigrid","page":"-","title":"LFAToolkit.PMultigrid","text":"Pmultigrid(fineoperator, coarseoperator, smoother, prolongation)\n\nP-Multigrid preconditioner for finite element operators\n\nArguments:\n\nfineoperator:       finite element operator to precondition\ncoarseoperator:     coarse grid representation of finite element operator to                           precondition\nsmoother:           error relaxation operator, such as Jacobi\nprolongationbases:  element prolongation bases from coarse to fine grid\n\nReturns:\n\nP-multigrid preconditioner object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nctofbasis = TensorH1LagrangePProlongationBasis(3, 5, 1, 2);\n\n# operators\nfinediffusion = GalleryOperator(\"diffusion\", 5, 5, mesh);\ncoarsediffusion = GalleryOperator(\"diffusion\", 3, 5, mesh);\n\n# smoother\njacobi = Jacobi(finediffusion);\n\n# preconditioner\nmultigrid = PMultigrid(finediffusion, coarsediffusion, jacobi, [ctofbasis]);\n\n# verify\nprintln(multigrid)\nprintln(multigrid.fineoperator)\n\n# output\np-multigrid preconditioner\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 5\n    numberquadraturepoints1d: 5\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\noperator field:\n  tensor product basis:\n    numbernodes1d: 5\n    numberquadraturepoints1d: 5\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 5\n    numberquadraturepoints1d: 5\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"public/pc/multigrid/#LFAToolkit.computesymbols-Tuple{Multigrid, Array, Array{Int64}, Array}","page":"-","title":"LFAToolkit.computesymbols","text":"computesymbols(multigrid, p, v, θ)\n\nCompute or retrieve the symbol matrix for a Jacobi preconditioned operator\n\nArguments:\n\nmultigrid:  multigrid preconditioner to compute symbol matrix for\np:          smoothing paramater array\nv:          pre and post smooths iteration count array, 0 indicates no pre or post smoothing\nθ:          Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the multigrid preconditioned operator\n\nExample:\n\nusing LinearAlgebra\n\nfor dimension in 1:3\n    # setup\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(1.0);\n    elseif dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    ctofbasis = TensorH1LagrangeBasis(3, 5, 1, dimension; collocatedquadrature=true);\n\n    # operators\n    finediffusion = GalleryOperator(\"diffusion\", 5, 5, mesh);\n    coarsediffusion = GalleryOperator(\"diffusion\", 3, 5, mesh);\n\n    # smoother\n    jacobi = Jacobi(finediffusion);\n\n    # preconditioner\n    multigrid = PMultigrid(finediffusion, coarsediffusion, jacobi, [ctofbasis]);\n\n    # compute symbols\n    A = computesymbols(multigrid, [1.0], [1, 1], π*ones(dimension));\n\n    # verify\n    eigenvalues = real(eigvals(A));\n    if dimension == 1\n       @assert maximum(eigenvalues) ≈ 0.64\n    elseif dimension == 2\n       @assert maximum(eigenvalues) ≈ 0.9082562365654528\n    elseif dimension == 3\n       @assert maximum(eigenvalues) ≈ 1.4359882222222669\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"public/pc/multigrid/#H-Multigrid","page":"-","title":"H-Multigrid","text":"","category":"section"},{"location":"public/pc/multigrid/#Example-2","page":"-","title":"Example","text":"","category":"section"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"This is an example of a simple h-multigrid preconditioner.","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex211_hmultigrid.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"Example plot for the symbol of h-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with linear basis.","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"This is an example of a multilevel h-multigrid preconditioner.","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"using Markdown \nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex212_hmultigrid_multilevel.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"Example plot for the symbol of multilevel h-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with linear basis.","category":"page"},{"location":"public/pc/multigrid/#Documentation-2","page":"-","title":"Documentation","text":"","category":"section"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"HMultigrid","category":"page"},{"location":"public/pc/multigrid/#LFAToolkit.HMultigrid","page":"-","title":"LFAToolkit.HMultigrid","text":"Hmultigrid(fineoperator, coarseoperator, smoother, prolongation)\n\nH-Multigrid preconditioner for finite element operators\n\nArguments:\n\nfineoperator:       finite element operator to precondition\ncoarseoperator:     coarse grid representation of finite element operator to                           precondition\nsmoother:           error relaxation operator, such as Jacobi\nprolongationbases:  element prolongation bases from coarse to fine grid\n\nReturns:\n\nH-multigrid preconditioner object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nctofbasis = TensorH1LagrangeHProlongationBasis(2, 1, 2, 2);\n\n# operators\nfunction diffusionweakform(du::Array{Float64}, w::Array{Float64})\n    dv = du*w[1]\n    return [dv]\nend\n# -- fine\nbasis = TensorH1LagrangeMacroBasis(2, 3, 1, 2, 2);\ninputs = [\n    OperatorField(basis, [EvaluationMode.gradient]),\n    OperatorField(basis, [EvaluationMode.quadratureweights]),\n];\noutputs = [OperatorField(basis, [EvaluationMode.gradient])];\nfinediffusion = Operator(diffusionweakform, mesh, inputs, outputs);\n# -- fine\nbasis = TensorH1LagrangeBasis(2, 3, 1, 2);\ninputs = [\n    OperatorField(basis, [EvaluationMode.gradient]),\n    OperatorField(basis, [EvaluationMode.quadratureweights]),\n];\noutputs = [OperatorField(basis, [EvaluationMode.gradient])];\ncoarsediffusion = Operator(diffusionweakform, mesh, inputs, outputs);\n\n# smoother\njacobi = Jacobi(finediffusion);\n\n# preconditioner\nmultigrid = HMultigrid(finediffusion, coarsediffusion, jacobi, [ctofbasis]);\n\n# verify\nprintln(multigrid)\nprintln(multigrid.fineoperator)\n\n# output\nh-multigrid preconditioner\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  macro-element tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 6\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n  evaluation mode:\n    gradient\noperator field:\n  macro-element tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 6\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  macro-element tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 6\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"public/pc/chebyshev/#Preconditioner:-Chebyshev","page":"-","title":"Preconditioner: Chebyshev","text":"","category":"section"},{"location":"public/pc/chebyshev/","page":"-","title":"-","text":"This smoother provides Chekyshev polynomial smoothing of a runtime specified order.","category":"page"},{"location":"public/pc/chebyshev/#Example","page":"-","title":"Example","text":"","category":"section"},{"location":"public/pc/chebyshev/","page":"-","title":"-","text":"This is an example of a Chebyshev smoother.","category":"page"},{"location":"public/pc/chebyshev/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex111_chebyshev.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/chebyshev/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/chebyshev/","page":"-","title":"-","text":"Plot for the symbol a cubic Chebyshev smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"public/pc/chebyshev/#Documentation","page":"-","title":"Documentation","text":"","category":"section"},{"location":"public/pc/chebyshev/","page":"-","title":"-","text":"Chebyshev\nseteigenvalueestimatescaling\ncomputesymbols(::Chebyshev, ::Array, ::Array)","category":"page"},{"location":"public/pc/chebyshev/#LFAToolkit.Chebyshev","page":"-","title":"LFAToolkit.Chebyshev","text":"Chebyshev(operator)\n\nChebyshev polynomial preconditioner for finite element operators.     The Chebyshev semi-iterative method is applied to the matrix D^-1 A,     where D^-1 is the inverse of the operator diagonal.\n\nArguments:\n\noperator:  finite element operator to precondition\n\nReturns:\n\nChebyshev preconditioner object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# preconditioner\nchebyshev = Chebyshev(mass);\n\n# verify\nprintln(chebyshev)\n\n# output\nchebyshev preconditioner:\neigenvalue estimates:\n  estimated minimum 0.2500\n  estimated maximum 1.3611\nestimate scaling:\n  λ_min = a * estimated min + b * estimated max\n  λ_max = c * estimated min + d * estimated max\n  a = 0.0000\n  b = 0.1000\n  c = 0.0000\n  d = 1.0000\n\n\n\n\n\n","category":"type"},{"location":"public/pc/chebyshev/#LFAToolkit.seteigenvalueestimatescaling","page":"-","title":"LFAToolkit.seteigenvalueestimatescaling","text":"seteigenvalueestimatescaling(preconditioner, eigenvaluebounds)\n\nSet the scaling of the eigenvalue estimates for a Chebyshev preconditioner\n\nArguments:\n\npreconditioner:    preconditioner to set eigenvalue estimate scaling\neigenvaluebounds:  array of 4 scaling factors to use when setting lambda_textmin                          and lambda_textmax based on eigenvalue estimates\n\nlambda_textmin = a * estimated min + b * estimated max\n\nlambda_textmax = c * estimated min + d * estimated max\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n# preconditioner\nchebyshev = Chebyshev(diffusion)\n\n# set eigenvalue estimate scaling\n# PETSc default is to use 1.1, 0.1 of max eigenvalue estimate\n#   https://www.mcs.anl.gov/petsc/petsc-3.3/docs/manualpages/KSP/KSPChebyshevSetEstimateEigenvalues.html\nseteigenvalueestimatescaling(chebyshev, [0.0, 0.1, 0.0, 1.1]);\nprintln(chebyshev)\n \n# output\nchebyshev preconditioner:\neigenvalue estimates:\n  estimated minimum 0.0000\n  estimated maximum 2.1429\nestimate scaling:\n  λ_min = a * estimated min + b * estimated max\n  λ_max = c * estimated min + d * estimated max\n  a = 0.0000\n  b = 0.1000\n  c = 0.0000\n  d = 1.1000\n\n\n\n\n\n","category":"function"},{"location":"public/pc/chebyshev/#LFAToolkit.computesymbols-Tuple{Chebyshev, Array, Array}","page":"-","title":"LFAToolkit.computesymbols","text":"computesymbols(preconditioner, ω, θ)\n\nCompute or retrieve the symbol matrix for a Chebyshev preconditioned operator\n\nArguments:\n\npreconditioner:  Chebyshev preconditioner to compute symbol matrix for\nω:               smoothing parameter array                        [degree], [degree, lambda_textmax], or                        [degree, lambda_textmin, lambda_textmax]\nθ:               Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the Chebyshev preconditioned operator\n\nExample:\n\nusing LinearAlgebra\n\nfor dimension in 1:3\n    # setup\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(1.0);\n    elseif dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    diffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n    # preconditioner\n    chebyshev = Chebyshev(diffusion);\n\n    # compute symbols\n    A = computesymbols(chebyshev, [1], π*ones(dimension));\n\n    # verify\n    using LinearAlgebra;\n    eigenvalues = real(eigvals(A));\n    if dimension == 1\n        @assert minimum(eigenvalues) ≈ 0.15151515151515105\n        @assert maximum(eigenvalues) ≈ 0.27272727272727226\n    elseif dimension == 2\n        @assert minimum(eigenvalues) ≈ -0.25495098334134725\n        @assert maximum(eigenvalues) ≈ -0.17128758445192374\n    elseif dimension == 3\n        @assert minimum(eigenvalues) ≈ -0.8181818181818181\n        @assert maximum(eigenvalues) ≈ -0.357575757575757\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/pc/multigrid/#Preconditioner:-Multigrid","page":"-","title":"Preconditioner: Multigrid","text":"","category":"section"},{"location":"private/pc/multigrid/","page":"-","title":"-","text":"Multigrid\nLFAToolkit.getnodecoordinatedifferences(::Multigrid)\nLFAToolkit.getprolongationmatrix\nLFAToolkit.computesymbolsprolongation(::Multigrid, ::Array)","category":"page"},{"location":"private/pc/multigrid/#LFAToolkit.Multigrid","page":"-","title":"LFAToolkit.Multigrid","text":"Multigrid(fineoperator, coarseoperator, smoother, prolongation, multigridtype)\n\nMultigrid preconditioner for finite element operators\n\nArguments:\n\nfineoperator:       finite element operator to precondition\ncoarseoperator:     coarse grid representation of finite element operator to                           precondition\nsmoother:           error relaxation operator, such as Jacobi\nprolongationbases:  element prolongation bases from coarse to fine grid\n\nReturns:\n\nMultigrid preconditioner object\n\n\n\n\n\n","category":"type"},{"location":"private/pc/multigrid/#LFAToolkit.getnodecoordinatedifferences-Tuple{Multigrid}","page":"-","title":"LFAToolkit.getnodecoordinatedifferences","text":"getnodecoordinateddifferences(multigrid)\n\nCompute or retrieve the array of differences in coordinates between nodes\n\nArguments:\n\npreconditioner:  preconditioner to compute node coordinate differences\n\nReturns:\n\nArray of differences in coordinates between nodes\n\n\n\n\n\n","category":"method"},{"location":"private/pc/multigrid/#LFAToolkit.getprolongationmatrix","page":"-","title":"LFAToolkit.getprolongationmatrix","text":"getprolongationmatrix(multigrid)\n\nCompute or retrieve the prolongation matrix\n\nArguments:\n\npreconditioner:  preconditioner to compute prolongation matrix\n\nReturns:\n\nMatrix prolonging from coarse grid to fine grid\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nctofbasis = TensorH1LagrangeBasis(2, 3, 1, 2; collocatedquadrature=true);\n\n# operators\nfinediffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\ncoarsediffusion = GalleryOperator(\"diffusion\", 2, 3, mesh);\n\n# smoother\njacobi = Jacobi(finediffusion);\n\n# preconditioner\nmultigrid = PMultigrid(finediffusion, coarsediffusion, jacobi, [ctofbasis]);\n\n# verify\nu = ones(ctofbasis.numbernodes);\nv = multigrid.prolongationmatrix * u;\n@assert v' ≈ [4. 2. 4. 2. 1. 2. 4. 2. 4.].^-1\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/pc/multigrid/#LFAToolkit.computesymbolsprolongation-Tuple{Multigrid, Array}","page":"-","title":"LFAToolkit.computesymbolsprolongation","text":"computesymbolsprolongation(multigrid, θ)\n\nCompute the symbol matrix for a multigrid prolongation operator\n\nArguments:\n\npreconditioner:  preconditioner to compute prolongation symbol\n\nArguments:\n\nmultigrid: Multigrid operator to compute prolongation symbol matrix for\nθ:         Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the multigrid prolongation operator\n\n\n\n\n\n","category":"method"},{"location":"public/pc/jacobi/#Preconditioner:-Jacobi","page":"-","title":"Preconditioner: Jacobi","text":"","category":"section"},{"location":"public/pc/jacobi/","page":"-","title":"-","text":"This smoother provides Jacobi smoothing based on the operator diagonal.","category":"page"},{"location":"public/pc/jacobi/#Example","page":"-","title":"Example","text":"","category":"section"},{"location":"public/pc/jacobi/","page":"-","title":"-","text":"This is an example of a simple Jacobi smoother.","category":"page"},{"location":"public/pc/jacobi/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex101_jacobi.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/jacobi/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/jacobi/","page":"-","title":"-","text":"Plot for the symbol of a Jacobi smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"public/pc/jacobi/#Documentation","page":"-","title":"Documentation","text":"","category":"section"},{"location":"public/pc/jacobi/","page":"-","title":"-","text":"Jacobi\ncomputesymbols(::Jacobi, ::Array, ::Array)","category":"page"},{"location":"public/pc/jacobi/#LFAToolkit.Jacobi","page":"-","title":"LFAToolkit.Jacobi","text":"Jacobi(operator)\n\nJacobi diagonal preconditioner for finite element operators\n\nArguments:\n\noperator:  finite element operator to precondition\n\nReturns:\n\nJacobi preconditioner object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# preconditioner\njacobi = Jacobi(mass);\n\n# verify\nprintln(jacobi)\nprintln(jacobi.operator)\n\n# output\njacobi preconditioner\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\n\n\n\n\n\n","category":"type"},{"location":"public/pc/jacobi/#LFAToolkit.computesymbols-Tuple{Jacobi, Array, Array}","page":"-","title":"LFAToolkit.computesymbols","text":"computesymbols(preconditioner, ω, θ)\n\nCompute or retrieve the symbol matrix for a Jacobi preconditioned operator\n\nArguments:\n\npreconditioner:  Jacobi preconditioner to compute symbol matrix for\nω:               smoothing weighting factor array\nθ:               Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the Jacobi preconditioned operator\n\nExample:\n\nusing LinearAlgebra\n\nfor dimension in 1:3\n    # setup\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(1.0);\n    elseif dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    diffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n    # preconditioner\n    jacobi = Jacobi(diffusion);\n\n    # compute symbols\n    A = computesymbols(jacobi, [1.0], π*ones(dimension));\n\n    # verify\n    using LinearAlgebra;\n    eigenvalues = real(eigvals(A));\n    if dimension == 1\n        @assert maximum(eigenvalues) ≈ 1/7\n    elseif dimension == 2\n        @assert minimum(eigenvalues) ≈ -1/14\n    elseif dimension == 3\n        @assert minimum(eigenvalues) ≈ -0.33928571428571486\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"examples/hyperelasticity/#Neo-Hookean-hyperelasticity","page":"-","title":"Neo-Hookean hyperelasticity","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"-","title":"-","text":"This is an example of a p-multigrid preconditioner with Chebyshev smoothing for the 3D Neo-Hookean hyperelasticity problem.","category":"page"},{"location":"examples/hyperelasticity/#Problem-formulation","page":"-","title":"Problem formulation","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"-","title":"-","text":"The strong form of the static balance of linear-momentum at finite strain is given by","category":"page"},{"location":"examples/hyperelasticity/","page":"-","title":"-","text":"-nabla_x cdot boldP - rho_0 boldg = bold0","category":"page"},{"location":"examples/hyperelasticity/","page":"-","title":"-","text":"where -nabla_k is the gradient with respect to the reference configuration, boldP is the first Piola-Kirchhoff stress tensor, rho_0 is the reference mass density, and boldg is the forcing function.","category":"page"},{"location":"examples/hyperelasticity/","page":"-","title":"-","text":"The first Piola-Kirchhoff stress tensor is given by","category":"page"},{"location":"examples/hyperelasticity/","page":"-","title":"-","text":"boldP = boldF boldS","category":"page"},{"location":"examples/hyperelasticity/","page":"-","title":"-","text":"where boldF is the deformation gradient and boldS is the second Piola-Kirchhoff stress tensor. In this example, the second Piola-Kirchhoff stress tensor is given by the Neo-Hookean model.","category":"page"},{"location":"examples/hyperelasticity/","page":"-","title":"-","text":"For a full discussion of the formulation of the 3D Neo-Hookean hyperelasticity problem, see the libCEED documentation.","category":"page"},{"location":"examples/hyperelasticity/#LFAToolkit-code","page":"-","title":"LFAToolkit code","text":"","category":"section"},{"location":"examples/hyperelasticity/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex311_hyperelasticity.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"private/pc/base/#Preconditioner:-Abstract-Base-Class","page":"-","title":"Preconditioner: Abstract Base Class","text":"","category":"section"},{"location":"private/pc/base/","page":"-","title":"-","text":"LFAToolkit.AbstractPreconditioner","category":"page"},{"location":"private/pc/base/#LFAToolkit.AbstractPreconditioner","page":"-","title":"LFAToolkit.AbstractPreconditioner","text":"Finite element operator preconditioner \n\n\n\n\n\n","category":"type"},{"location":"private/operator/#Finite-Element-Operator","page":"-","title":"Finite Element Operator","text":"","category":"section"},{"location":"private/operator/","page":"-","title":"-","text":"LFAToolkit.getdimension\nLFAToolkit.getelementmatrix\nLFAToolkit.getmultiplicity\nLFAToolkit.getrowmodemap(::Operator)\nLFAToolkit.getcolumnmodemap(::Operator)\nLFAToolkit.getinputcoordinates\nLFAToolkit.getoutputcoordinates\nLFAToolkit.getnodecoordinatedifferences(::Operator)\nLFAToolkit.massoperator\nLFAToolkit.diffusionoperator\nLFAToolkit.advectionoperator\nLFAToolkit.supgadvectionoperator\nLFAToolkit.supgmassoperator","category":"page"},{"location":"private/operator/#LFAToolkit.getdimension","page":"-","title":"LFAToolkit.getdimension","text":"getdimension(operator)\n\nRetrieve the dimension of an operator\n\nArguments:\n\noperator:  operator to retrieve the dimension\n\nReturns:\n\nDimension of the operator\n\nExample\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# verify\n@assert mass.dimension == 2\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getelementmatrix","page":"-","title":"LFAToolkit.getelementmatrix","text":"getelementmatrix(operator)\n\nCompute or retrieve the element matrix of operator for computing the symbol\n\nArguments:\n\noperator:  operator to compute element matrix\n\nReturns:\n\nAssembled element matrix\n\nMass matrix example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# element matrix computation\n# note: either syntax works\nelementmatrix = LFAToolkit.getelementmatrix(mass);\nelementmatrix = mass.elementmatrix;\n\n# verify\nu = ones(4*4);\nv = elementmatrix*u;\n\ntotal = sum(v);\n@assert total ≈ 1.0\n\n# output\n\n\nDiffusion matrix example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\ndiffusion = GalleryOperator(\"diffusion\", 4, 4, mesh);\n\n# element matrix computation\n# note: either syntax works\nelementmatrix = LFAToolkit.getelementmatrix(diffusion);\nelementmatrix = diffusion.elementmatrix;\n\n# verify\nu = ones(4*4);\nv = elementmatrix*u;\n\ntotal = sum(v);\n@assert abs(total) < 1e-14\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getmultiplicity","page":"-","title":"LFAToolkit.getmultiplicity","text":"getmultiplicity(operator)\n\nCompute or retrieve the vector of node multiplicity for the operator\n\nArguments:\n\noperator:  operator to compute node multiplicity\n\nReturns:\n\nVector of node multiplicity for the operator\n\nExample\n\n```jldoctest for dimension in 1:3     # setup     mesh = []     if dimension == 1         mesh = Mesh1D(1.0);     elseif dimension == 2         mesh = Mesh2D(1.0, 1.0);     elseif dimension == 3         mesh = Mesh3D(1.0, 1.0, 1.0);     end     diffusion = GalleryOperator(\"diffusion\", 5, 5, mesh);\n\n# compute multiplicity\nmultiplicity = diffusion.multiplicity;\n\n# verify\nmultiplicity1D = [2. 1. 1. 1. 2.]';\nif dimension == 1\n    @assert multiplicity ≈ multiplicity1D\nelseif dimension == 2\n    @assert multiplicity ≈ kron(multiplicity1D, multiplicity1D)\nelseif dimension == 3\n    @assert multiplicity ≈ kron(multiplicity1D, multiplicity1D, multiplicity1D)\nend\n\nend\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getrowmodemap-Tuple{Operator}","page":"-","title":"LFAToolkit.getrowmodemap","text":"getrowmodemap(operator)\n\nCompute or retrieve the matrix mapping the rows of the element matrix to the symbol matrix\n\nArguments:\n\noperator:  operator to compute row mode map\n\nReturns:\n\nMatrix mapping rows of element matrix to symbol matrix\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# note: either syntax works\nmodemap = LFAToolkit.getrowmodemap(mass);\nmodemap = mass.rowmodemap;\n\n# verify\n@assert modemap ≈ [1 0 0 1; 0 1 0 0; 0 0 1 0]\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/operator/#LFAToolkit.getcolumnmodemap-Tuple{Operator}","page":"-","title":"LFAToolkit.getcolumnmodemap","text":"getcolumnmodemap(operator)\n\nCompute or retrieve the matrix mapping the columns of the element matrix to the   symbol matrix\n\nArguments:\n\noperator:  operator to compute column mode map\n\nReturns:\n\nMatrix mapping columns of element matrix to symbol matrix\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# note: either syntax works\nmodemap = LFAToolkit.getcolumnmodemap(mass);\nmodemap = mass.columnmodemap;\n\n# verify\n@assert modemap ≈ [1 0 0; 0 1 0; 0 0 1; 1 0 0]\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/operator/#LFAToolkit.getinputcoordinates","page":"-","title":"LFAToolkit.getinputcoordinates","text":"getinputcoordinates(operator)\n\nCompute or retrieve the array of input coordinates\n\nArguments:\n\noperator:  operator to get input coordinates\n\nReturns:\n\nArray of input coordinates\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getoutputcoordinates","page":"-","title":"LFAToolkit.getoutputcoordinates","text":"getoutputcoordinates(operator)\n\nCompute or retrieve the array of output coordinates\n\nArguments:\n\noperator:  operator to get output coordinates\n\nReturns:\n\nArray of output coordinates\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getnodecoordinatedifferences-Tuple{Operator}","page":"-","title":"LFAToolkit.getnodecoordinatedifferences","text":"getnodecoordinatedifferences(operator)\n\nCompute or retrieve the array of differences in coordinates between nodes\n\nArguments:\n\noperator:  operator to compute differences between node coordinates\n\nReturns:\n\nArray of differences in coordinates between nodes\n\nExample:\n\nusing FastGaussQuadrature\n\n# setup\nmesh = Mesh1D(1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# note: either syntax works\nnodedifferences = LFAToolkit.getnodecoordinatedifferences(mass);\nnodedifferences = mass.nodecoordinatedifferences;\n\n# verify\ntruenodes, = gausslobatto(4);\ntruenodedifferences = [\n    (truenodes[j] - truenodes[i])/2.0 for i in 1:4, j in 1:4\n];\n@assert nodedifferences ≈ truenodedifferences\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/operator/#LFAToolkit.massoperator","page":"-","title":"LFAToolkit.massoperator","text":"massoperator(basis, mesh; parameters)\n\nConvenience constructor for mass operator\n\nWeak form:\n\nint v u\n\nArguments:\n\nbasis:  basis for all operator fields to use\nmesh:   mesh for operator\n\nKeyword Arguments:\n\nparameters = nothing:  named tuple of model parameters                              default: nothing, no parameters\n\nReturns:\n\nMass matrix operator with basis on mesh\n\nExample:\n\n# mass operator\nmesh = Mesh2D(1.0, 1.0);\nbasis = TensorH1LagrangeBasis(3, 4, 1, mesh.dimension);\nmass = LFAToolkit.massoperator(basis, mesh);\n\n# verify\nprintln(mass)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.diffusionoperator","page":"-","title":"LFAToolkit.diffusionoperator","text":"diffusionoperator(basis, mesh; parameters)\n\nConvenience constructor for diffusion operator\n\nWeak form:\n\nint nabla v nabla u\n\nArguments:\n\nbasis:  basis for all operator fields to use\nmesh:   mesh for operator\n\nKeyword Arguments:\n\nparameters = nothing:  named tuple of model parameters                              default: nothing, no parameters\n\nReturns:\n\nDiffusion operator with basis on mesh\n\nExample:\n\n# diffusion operator\nmesh = Mesh2D(1.0, 1.0);\nbasis = TensorH1LagrangeBasis(3, 4, 1, mesh.dimension);\ndiffusion = LFAToolkit.diffusionoperator(basis, mesh);\n\n# verify\nprintln(diffusion)\n\n# output\n\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.advectionoperator","page":"-","title":"LFAToolkit.advectionoperator","text":"advectionoperator(basis, mesh; parameters)\n\nConvenience constructor for advection operator\n\nWeak form:\n\nint nabla v u\n\nArguments:\n\nbasis:  basis for all operator fields to use\nmesh:   mesh for operator\n\nKeyword Arguments:\n\nparameters = ([wind = [1., 1.],):  named tuple of model parameters, defines wind speed                                          default: wind speed = [1.0, 1.0]\n\nReturns:\n\nAdvection operator with basis on mesh\n\nExample:\n\n# advection operator\nmesh = Mesh2D(1.0, 1.0);\nmapping = hale_trefethen_strip_transformation(1.4);\nbasis = TensorH1LagrangeBasis(3, 4, 1, mesh.dimension, collocatedquadrature = false, mapping = mapping);\nparameters = (wind = [1., 1.],);\nadvection = LFAToolkit.advectionoperator(basis, mesh; parameters = parameters);\n\n# verify\nprintln(advection)\n\n# output\n\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.supgadvectionoperator","page":"-","title":"LFAToolkit.supgadvectionoperator","text":"supgadvectionoperator(basis, mesh; parameters)\n\nConvenience constructor for SUPG advection operator\n\nWeak form: Right hand side\n\nint wind nabla v u - wind wind τ nabla v nabla u\n\nArguments:\n\nbasis:  basis for all operator fields to use\nmesh:   mesh for operator\n\nKeyword Arguments:\n\nparameters = ([wind = [1., 1.], τ = 1.0):  named tuple of model parameters, defines wind speed and SUPG scaling                                                  default: wind speed = [1.0, 1.0], τ = 1.0\n\nReturns:\n\nSUPG advection operator with basis on mesh\n\nExample:\n\n# supg advection operator\nmesh = Mesh2D(1.0, 1.0);\nmapping = nothing;\nbasis = TensorH1LagrangeBasis(3, 4, 1, mesh.dimension, collocatedquadrature = false, mapping = mapping);\nparameters = (wind = [1., 1.], τ = 1.0);\nsupgadvection = LFAToolkit.supgadvectionoperator(basis, mesh; parameters = parameters);\n\n# verify\nprintln(supgadvection)\n\n# output\n\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation modes:\n    interpolation\n    gradient\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.supgmassoperator","page":"-","title":"LFAToolkit.supgmassoperator","text":"supgmassoperator(basis, mesh; parameters)\n\nConvenience constructor for SUPG mass matrix operator\n\nWeak form: Left hand side\n\nint v u_t + wind τ u_t nabla v\n\nArguments:\n\nbasis:  basis for all operator fields to use\nmesh:   mesh for operator\n\nKeyword Arguments:\n\nparameters = ([wind = [1., 1.], τ = 1.0):  named tuple of model parameters, defines wind speed and SUPG scaling                                                  default: wind speed = [1.0, 1.0], τ = 1.0\n\nReturns:\n\nSUPG mass matrix operator with basis on mesh\n\nExample:\n\n# supg mass matrix operator\nmesh = Mesh2D(1.0, 1.0);\nmapping = nothing;\nbasis = TensorH1LagrangeBasis(3, 4, 1, mesh.dimension, collocatedquadrature = false, mapping = mapping);\nparameters = (wind = [1., 1.], τ = 1.0);\nsupgmass = LFAToolkit.supgmassoperator(basis, mesh; parameters = parameters);\n\n# verify\nprintln(supgmass)\n\n# output\n\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation modes:\n    interpolation\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#Preconditioner:-BDDC","page":"-","title":"Preconditioner: BDDC","text":"","category":"section"},{"location":"private/pc/bddc/","page":"-","title":"-","text":"BDDC\nLFAToolkit.getprimalnodes(::BDDC)\nLFAToolkit.getsubassemblednodes(::BDDC)\nLFAToolkit.getinterfacenodes(::BDDC)\nLFAToolkit.getinteriornodes(::BDDC)\nLFAToolkit.getprimalmodes\nLFAToolkit.getsubassembledmodes\nLFAToolkit.getinterfacemodes\nLFAToolkit.getinteriormodes\nLFAToolkit.getsubassembledinverse\nLFAToolkit.getinteriorinverse\nLFAToolkit.getschur\nLFAToolkit.getmixedmultiplicity\nLFAToolkit.getJDT\nLFAToolkit.getprimalrowmodemap\nLFAToolkit.getprimalcolumnmodemap\nLFAToolkit.getsubassembledrowmodemap\nLFAToolkit.getsubassembledcolumnmodemap\nLFAToolkit.getmixedrowmodemap\nLFAToolkit.getmixedcolumnmodemap\nLFAToolkit.getmodepermutation\nLFAToolkit.computesymbolsinjection(::BDDC, ::Array)","category":"page"},{"location":"private/pc/bddc/#LFAToolkit.BDDC","page":"-","title":"LFAToolkit.BDDC","text":"BDDC(operator, coarseoperator, smoother, prolongation)\n\nBDDC preconditioner for finite element operators\n\nArguments:\n\noperator:       finite element operator to precondition\ninjectiontype:  type of injection into subassembled space to use\n\nReturns:\n\nBDDC preconditioner object\n\n\n\n\n\n","category":"type"},{"location":"private/pc/bddc/#LFAToolkit.getprimalnodes-Tuple{BDDC}","page":"-","title":"LFAToolkit.getprimalnodes","text":"getprimalnodes(bddc)\n\nCompute or retrieve the primal nodes for a BDDC preconditioner\n\nReturns:\n\nVector of primal nodes for BDDC preconditioner\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\np = 4\ndiffusion = GalleryOperator(\"diffusion\", p, p, mesh);\nbddc = LumpedBDDC(diffusion)\n\n# note: either syntax works\nprimalnodes = LFAToolkit.getprimalnodes(bddc);\nprimalnodes = bddc.primalnodes;\n\n# verify\n@assert primalnodes == [1, p, p^2 - p + 1, p^2]\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/pc/bddc/#LFAToolkit.getsubassemblednodes-Tuple{BDDC}","page":"-","title":"LFAToolkit.getsubassemblednodes","text":"getsubassemblednodes(bddc)\n\nCompute or retrieve the subassembled nodes for a BDDC preconditioner\n\nArguments:\n\npreconditioner:  preconditioner to compute sumassembled nodes\n\nReturns:\n\nVector of subassembled nodes for BDDC preconditioner\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\np = 4\ndiffusion = GalleryOperator(\"diffusion\", p, p, mesh);\nbddc = LumpedBDDC(diffusion)\n\n# note: either syntax works\nsubassemblednodes = LFAToolkit.getsubassemblednodes(bddc);\nsubassemblednodes = bddc.subassemblednodes;\n\n# verify\n@assert subassemblednodes == setdiff(1:p^2, [1, p, p^2-p+1, p^2])\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/pc/bddc/#LFAToolkit.getinterfacenodes-Tuple{BDDC}","page":"-","title":"LFAToolkit.getinterfacenodes","text":"getinterfacenodes(bddc)\n\nCompute or retrieve the interface nodes for a BDDC preconditioner\n\nArguments:\n\npreconditioner:  preconditioner to compute interface nodes\n\nReturns:\n\nVector of interface nodes for BDDC preconditioner\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\np = 4\ndiffusion = GalleryOperator(\"diffusion\", p, p, mesh);\nbddc = LumpedBDDC(diffusion)\n\n# note: either syntax works\ninterfacenodes = LFAToolkit.getinterfacenodes(bddc);\ninterfacenodes = bddc.interfacenodes;\n\n# verify\ntrueinterfacenodes = [1:p..., p^2-p+1:p^2...]\nfor i = 1:p-2\n    push!(trueinterfacenodes, i*p+1)\n    push!(trueinterfacenodes, (i+1)*p)\nend\ntrueinterfacenodes = sort(trueinterfacenodes)\ntrueinterfacenodes = setdiff(trueinterfacenodes, bddc.primalnodes)\n@assert interfacenodes == trueinterfacenodes\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/pc/bddc/#LFAToolkit.getinteriornodes-Tuple{BDDC}","page":"-","title":"LFAToolkit.getinteriornodes","text":"getinteriornodes(bddc)\n\nCompute or retrieve the interior nodes for a BDDC preconditioner\n\nArguments:\n\npreconditioner:  preconditioner to compute interior nodes\n\nReturns:\n\nVector of interior nodes for BDDC preconditioner\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\np = 4\ndiffusion = GalleryOperator(\"diffusion\", p, p, mesh);\nbddc = LumpedBDDC(diffusion)\n\n# note: either syntax works\ninteriornodes = LFAToolkit.getinteriornodes(bddc);\ninteriornodes = bddc.interiornodes;\n\n# verify\ntrueinterfacenodes = [1:p..., p^2-p+1:p^2...]\nfor i = 1:p-2\n    push!(trueinterfacenodes, i*p+1)\n    push!(trueinterfacenodes, (i+1)*p)\nend\ntrueinterfacenodes = sort(trueinterfacenodes)\ntrueinteriornodes = setdiff(bddc.subassemblednodes, trueinterfacenodes)\n@assert interiornodes == trueinteriornodes\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/pc/bddc/#LFAToolkit.getprimalmodes","page":"-","title":"LFAToolkit.getprimalmodes","text":"getprimalmodes(bddc)\n\nCompute or retrieve the primal modes for a BDDC preconditioner\n\nArguments:\n\npreconditioner:  preconditioner to compute primal nodes\n\nReturns:\n\nVector of primal modes for BDDC preconditioner\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\np = 4\ndiffusion = GalleryOperator(\"diffusion\", p, p, mesh);\nbddc = LumpedBDDC(diffusion)\n\n# note: either syntax works\nprimalmodes = LFAToolkit.getprimalmodes(bddc);\nprimalmodes = bddc.primalmodes;\n\n# verify\n@assert primalmodes == [1]\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.getsubassembledmodes","page":"-","title":"LFAToolkit.getsubassembledmodes","text":"getsubassembledmodes(bddc)\n\nCompute or retrieve the subassembled modes for a BDDC preconditioner\n\nArguments:\n\npreconditioner:  preconditioner to compute subassembled modes\n\nReturns:\n\nVector of subassembled modes for BDDC preconditioner\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\np = 4\ndiffusion = GalleryOperator(\"diffusion\", p, p, mesh);\nbddc = LumpedBDDC(diffusion)\n\n# note: either syntax works\nsubassembledmodes = LFAToolkit.getsubassembledmodes(bddc);\nsubassembledmodes = bddc.subassembledmodes;\n\n# verify\n@assert subassembledmodes == setdiff(1:(p-1)^2, [1])\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.getinterfacemodes","page":"-","title":"LFAToolkit.getinterfacemodes","text":"getinterfacemodes(bddc)\n\nCompute or retrieve the interface modes for a BDDC preconditioner\n\nArguments:\n\npreconditioner:  preconditioner to compute interface modes\n\nReturns:\n\nVector of interface modes for BDDC preconditioner\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\np = 4\ndiffusion = GalleryOperator(\"diffusion\", p, p, mesh);\nbddc = LumpedBDDC(diffusion)\n\n# note: either syntax works\ninterfacemodes = LFAToolkit.getinterfacemodes(bddc);\ninterfacemodes = bddc.interfacemodes;\n\n# verify\ntrueinterfacemodes = [1:p-1...]\nfor i = 1:p-2\n    push!(trueinterfacemodes, i*(p-1)+1)\nend\ntrueinterfacemodes = sort(trueinterfacemodes)\ntrueinterfacemodes = setdiff(trueinterfacemodes, bddc.primalmodes)\n@assert interfacemodes == trueinterfacemodes\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.getinteriormodes","page":"-","title":"LFAToolkit.getinteriormodes","text":"getinteriormodes(bddc)\n\nCompute or retrieve the interior modes for a BDDC preconditioner\n\nArguments:\n\npreconditioner:  preconditioner to compute interior modes\n\nReturns:\n\nVector of interior modes for BDDC preconditioner\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\np = 4\ndiffusion = GalleryOperator(\"diffusion\", p, p, mesh);\nbddc = LumpedBDDC(diffusion)\n\n# note: either syntax works\ninteriormodes = LFAToolkit.getinteriormodes(bddc);\ninteriormodes = bddc.interiormodes;\n\n# verify\n@assert interiormodes == setdiff(bddc.subassembledmodes, bddc.interfacemodes)\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.getsubassembledinverse","page":"-","title":"LFAToolkit.getsubassembledinverse","text":"getsubassembledinverse(bddc)\n\nCompute or retrieve the solver for subdomain for a BDDC preconditioner\n\nArguments:\n\npreconditioner:  preconditioner to compute subdomain solver\n\nReturns:\n\nSolver for subdomain\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\np = 4\ndiffusion = GalleryOperator(\"diffusion\", p, p, mesh);\nbddc = LumpedBDDC(diffusion)\n\n# note: either syntax works\nsubassembledinverse = LFAToolkit.getsubassembledinverse(bddc);\nsubassembledinverse = bddc.subassembledinverse;\n\n# verify\n@assert subassembledinverse ≈ Matrix(diffusion.elementmatrix[bddc.subassemblednodes, bddc.subassemblednodes])^-1\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.getinteriorinverse","page":"-","title":"LFAToolkit.getinteriorinverse","text":"getinteriorinverse(bddc)\n\nCompute or retrieve the solver for subdomain interior for a BDDC preconditioner\n\nArguments:\n\npreconditioner:  preconditioner to compute subdomain interior solver\n\nReturns:\n\nSolver for subdomain interior\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\np = 4\ndiffusion = GalleryOperator(\"diffusion\", p, p, mesh);\nbddc = LumpedBDDC(diffusion)\n\n# note: either syntax works\ninteriorinverse = LFAToolkit.getinteriorinverse(bddc);\ninteriorinverse = bddc.interiorinverse;\n\n# verify\n@assert interiorinverse ≈ Matrix(diffusion.elementmatrix[bddc.interiornodes, bddc.interiornodes])^-1\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.getschur","page":"-","title":"LFAToolkit.getschur","text":"getschur(bddc)\n\nCompute or retrieve the Schur complement matrix for a BDDC preconditioner\n\nArguments:\n\npreconditioner:  preconditioner to compute Schur complement matrix\n\nReturns:\n\nMatrix for Schur complement\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\np = 4\ndiffusion = GalleryOperator(\"diffusion\", p, p, mesh);\nbddc = LumpedBDDC(diffusion)\n\n# note: either syntax works\nschur = LFAToolkit.getschur(bddc);\nschur = bddc.schur;\n\n# verify\n@assert schur ≈ diffusion.elementmatrix[bddc.primalnodes, bddc.primalnodes] -\n    diffusion.elementmatrix[bddc.primalnodes, bddc.subassemblednodes] *\n    Matrix(diffusion.elementmatrix[bddc.subassemblednodes, bddc.subassemblednodes])^-1 *\n    diffusion.elementmatrix[bddc.subassemblednodes, bddc.primalnodes]\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.getmixedmultiplicity","page":"-","title":"LFAToolkit.getmixedmultiplicity","text":"getmixedmultiplicity(bddc)\n\nCompute or retrieve the diagonal matrix of mixed interface node and primal mode     multiplicity for the BDDC preconditioner\n\nArguments:\n\npreconditioner:  preconditioner to compute mixed node/mode multiplicity\n\nReturns:\n\nMatrix of mixed multiplicity for the BDDC preconditioner\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.getJDT","page":"-","title":"LFAToolkit.getJDT","text":"getJDT(bddc)\n\nCompute or retrieve the matrix mapping the jump over subdomain interface modes\n\nArguments:\n\npreconditioner:  preconditioner to compute jump mapping matrix\n\nReturns:\n\nMatrix mapping the jump over subdomain interfacemodes\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.getprimalrowmodemap","page":"-","title":"LFAToolkit.getprimalrowmodemap","text":"getprimalrowmodemap(bddc)\n\nCompute or retrieve the matrix mapping the rows of the primal BDDC matrix to the primal symbol matrix\n\nArguments:\n\npreconditioner:  preconditioner to compute primal row mode map\n\nReturns:\n\nMatrix mapping rows of primal BDDC matrix to primal symbol matrix\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\nbddc = LumpedBDDC(diffusion);\n\n# note: either syntax works\nprimalmodemap = LFAToolkit.getprimalrowmodemap(bddc);\nprimalmodemap = bddc.primalrowmodemap;\n\n# verify\n@assert primalmodemap ≈ [1 1 1 1]\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.getprimalcolumnmodemap","page":"-","title":"LFAToolkit.getprimalcolumnmodemap","text":"getprimalcolumnmodemap(bddc)\n\nCompute or retrieve the matrix mapping the columns of the primal BDDC matrix to the     primal symbol matrix\n\nArguments:\n\npreconditioner:  preconditioner to compute primal column mode map\n\nReturns:\n\nMatrix mapping columns of primal BDDC matrix to primal symbol matrix\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\nbddc = LumpedBDDC(diffusion);\n\n# note: either syntax works\nprimalmodemap = LFAToolkit.getprimalcolumnmodemap(bddc);\nprimalmodemap = bddc.primalcolumnmodemap;\n\n# verify\n@assert primalmodemap ≈ [1; 1; 1; 1]\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.getsubassembledrowmodemap","page":"-","title":"LFAToolkit.getsubassembledrowmodemap","text":"getsubassembledrowmodemap(bddc)\n\nCompute or retrieve the matrix mapping the rows of the subassembled BDDC matrix to the     subassembled symbol matrix\n\nArguments:\n\npreconditioner:  preconditioner to compute subassembled row mode map\n\nReturns:\n\nMatrix mapping rows of subassembled BDDC matrix to subassembled symbol matrix\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\nbddc = LumpedBDDC(diffusion);\n\n# note: either syntax works\nsubassembledmodemap = LFAToolkit.getsubassembledrowmodemap(bddc);\nsubassembledmodemap = bddc.subassembledrowmodemap;\n\n# verify\n@assert subassembledmodemap ≈ bddc.operator.rowmodemap[bddc.subassembledmodes, bddc.subassemblednodes]\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.getsubassembledcolumnmodemap","page":"-","title":"LFAToolkit.getsubassembledcolumnmodemap","text":"getsubassembledcolumnmodemap(bddc)\n\nCompute or retrieve the matrix mapping the columns of the subassembled BDDC matrix to the     subassembled symbol matrix\n\nArguments:\n\npreconditioner:  preconditioner to compute subassembled column mode map\n\nReturns:\n\nMatrix mapping columns of subassembled BDDC matrix to subassembled symbol matrix\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\nbddc = LumpedBDDC(diffusion);\n\n# note: either syntax works\nsubassembledmodemap = LFAToolkit.getsubassembledcolumnmodemap(bddc);\nsubassembledmodemap = bddc.subassembledcolumnmodemap;\n\n# verify\n@assert subassembledmodemap ≈ bddc.operator.columnmodemap[bddc.subassemblednodes, bddc.subassembledmodes]\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.getmixedrowmodemap","page":"-","title":"LFAToolkit.getmixedrowmodemap","text":"getmixedrowmodemap(bddc)\n\nCompute or retrieve the matrix mapping the rows of the mixed BDDC matrix to the     symbol matrix\n\nArguments:\n\npreconditioner:  preconditioner to compute mixed row mode map\n\nReturns:\n\nMatrix mapping rows of mixed BDDC matrix to symbol matrix\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.getmixedcolumnmodemap","page":"-","title":"LFAToolkit.getmixedcolumnmodemap","text":"getmixedcolumnmodemap(bddc)\n\nCompute or retrieve the matrix mapping the columns of the mixed BDDC matrix to the     symbol matrix\n\nArguments:\n\npreconditioner:  preconditioner to compute mixed column mode map\n\nReturns:\n\nMatrix mapping columns of mixed BDDC matrix to symbol matrix\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.getmodepermutation","page":"-","title":"LFAToolkit.getmodepermutation","text":"getmodepermutation(bddc)\n\nCompute or retrieve the matrix permuting multi-component modes to standard ordering\n\nArguments:\n\npreconditioner:  preconditioner to compute mode permutation matrix\n\nReturns:\n\nMatrix mapping BDDC mode ordering to standard ordering\n\n\n\n\n\n","category":"function"},{"location":"private/pc/bddc/#LFAToolkit.computesymbolsinjection-Tuple{BDDC, Array}","page":"-","title":"LFAToolkit.computesymbolsinjection","text":"computesymbolsinjection(bddc)\n\nCompute or retrieve the injection operator for the BDDC symbol matrix\n\nArguments:\n\npreconditioner:  preconditioner to compute injection matrix\n\nReturns:\n\nMatrix providing the injection operator of BDDC symbol matrix\n\n\n\n\n\n","category":"method"},{"location":"private/pc/jacobi/#Preconditioner:-Jacobi","page":"-","title":"Preconditioner: Jacobi","text":"","category":"section"},{"location":"private/pc/jacobi/","page":"-","title":"-","text":"LFAToolkit.getoperatordiagonalinverse(::Jacobi)","category":"page"},{"location":"private/pc/jacobi/#LFAToolkit.getoperatordiagonalinverse-Tuple{Jacobi}","page":"-","title":"LFAToolkit.getoperatordiagonalinverse","text":"getoperatordiagonalinverse(preconditioner)\n\nCompute or retrieve the inverse of the symbol matrix diagonal for a Jacobi     preconditioner\n\nArguments:\n\npreconditioner:  preconditioner to compute diagonal inverse\n\nReturns:\n\nSymbol matrix diagonal inverse for the operator\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n# preconditioner\njacobi = Jacobi(diffusion)\n\n# note: either syntax works\ndiagonalinverse = LFAToolkit.getoperatordiagonalinverse(jacobi);\ndiagonalinverse = jacobi.operatordiagonalinverse;\n\n# verify\n@assert diagonalinverse ≈ [6/7 0; 0 3/4]\n \n# output\n\n\n\n\n\n\n","category":"method"},{"location":"public/basis/#Finite-Element-Basis","page":"-","title":"Finite Element Basis","text":"","category":"section"},{"location":"public/basis/","page":"-","title":"-","text":"The finite element basis objects represent the discretization of the problem.","category":"page"},{"location":"public/basis/","page":"-","title":"-","text":"There are convenience constructors for H1 tensor product bases on uniformly spaced, Gauss-Lobatto, or Gauss-Legendre points with Gauss-Lobatto or Gauss-Legendre quadrature. There are also nonpolynomial bases available derived from conformal maps such as sausage_transformation, kosloff_talezer_transformation, and hale_trefethen_strip_transformation. Users can create additional finite element bases if the prerequisite information is provided.","category":"page"},{"location":"public/basis/#Base-Classes","page":"-","title":"Base Classes","text":"","category":"section"},{"location":"public/basis/","page":"-","title":"-","text":"These are the bases classes for finite element bases. The constructors for these base classes can be used to create user defined finite elements.","category":"page"},{"location":"public/basis/","page":"-","title":"-","text":"TensorBasis\nNonTensorBasis","category":"page"},{"location":"public/basis/#LFAToolkit.TensorBasis","page":"-","title":"LFAToolkit.TensorBasis","text":"TensorBasis(\n    numbernodes1d,\n    numberquadraturepoints1d,\n    numbercomponents,\n    dimension,\n    nodes1d,\n    quadraturepoints1d,\n    quadratureweights1d,\n    interpolation1d,\n    gradient1d\n)\n\nTensor product basis\n\nArguments:\n\nnumbernodes1d:             number of nodes in 1 dimension\nnumberquadraturepoints1d:  number of quadrature points in 1 dimension\nnumbercomponents:          number of components\ndimension:                 dimension of the basis\nnodes1d:                   coordinates of the nodes in 1 dimension\nquadraturepoints1d:        coordinates of the quadrature points in 1                                  dimension\nquadratureweights1d:       quadrature weights in 1 dimension\ninterpolation1d:           interpolation matrix from nodes to quadrature                                  points in 1 dimension\ngradient1d:                gradient matrix from nodes to quadrature points in                                  1 dimension\n\nReturns:\n\nTensor product basis object\n\n\n\n\n\n","category":"type"},{"location":"public/basis/#LFAToolkit.NonTensorBasis","page":"-","title":"LFAToolkit.NonTensorBasis","text":"NonTensorBasis(\n    numbernodes,\n    numberquadraturepoints,\n    numbercomponents,\n    dimension,\n    nodes,\n    quadraturepoints,\n    quadratureweights,\n    interpolation,\n    gradient\n)\n\nNon-tensor basis\n\nArguments:\n\nnumbernodes:             number of nodes \nnumberquadraturepoints:  number of quadrature points\nnumbercomponents:        number of components\ndimension:               dimension of the basis\nnodes:                   coordinates of the nodes\nquadraturepoints:        coordinates of the quadrature points\nquadratureweights:       quadrature weights\ninterpolation:           interpolation matrix from nodes to quadrature points\ngradient:                gradient matrix from nodes to quadrature points\n\nReturns:\n\nNon-tensor product basis object\n\n\n\n\n\n","category":"type"},{"location":"public/basis/#Singe-Element-Bases","page":"-","title":"Singe Element Bases","text":"","category":"section"},{"location":"public/basis/","page":"-","title":"-","text":"These bases represent common tensor product finite element bases used for continuous Galerkin methods.","category":"page"},{"location":"public/basis/","page":"-","title":"-","text":"TensorH1LagrangeBasis\nTensorH1UniformBasis","category":"page"},{"location":"public/basis/#LFAToolkit.TensorH1LagrangeBasis","page":"-","title":"LFAToolkit.TensorH1LagrangeBasis","text":"TensorH1LagrangeBasis(\n    numbernodes1d,\n    numberquadraturepoints1d,\n    numbercomponents,\n    dimension;\n    collocatedquadrature = false,\n    mapping = nothing,\n)\n\nTensor product basis on Gauss-Legendre-Lobatto points with Gauss-Legendre (default)   or Gauss-Legendre-Lobatto quadrature points\n\nArguments:\n\nnumbernodes1d:             number of Gauss-Legendre-Lobatto nodes in 1 dimension\nnumberquadraturepoints1d:  number of quadrature points in 1 dimension\nnumbercomponents:          number of components\ndimension:                 dimension of basis\n\nKeyword Arguments:\n\ncollocatedquadrature = false:   Gauss-Legendre or Gauss-Legendre-Lobatto quadrature points,                                   default: false, Gauss-Legendre-Lobatto\nmapping = nothing:              quadrature point mapping - sausage, Kosloff-Talezer,                                   or Hale-Trefethen strip transformation                                   default: nothing, no transformation\n\nReturns:\n\nH1 Lagrange tensor product basis object\n\nExample:\n\n# generate transformed basis from conformal maps with Gauss-Legendre quadrature points\nmapping = hale_trefethen_strip_transformation(1.4);\nbasis = TensorH1LagrangeBasis(4, 4, 3, 2, collocatedquadrature=true, mapping=mapping);\n\n# verify\nprintln(basis)\n\n# output\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 3\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#LFAToolkit.TensorH1UniformBasis","page":"-","title":"LFAToolkit.TensorH1UniformBasis","text":"TensorH1UniformBasis(\n    numbernodes1d,\n    numberquadraturepoints1d,\n    numbercomponents,\n    dimension,\n)\n\nTensor product basis on uniformly spaced points with Gauss-Legendre quadrature points\n\nArguments:\n\nnumbernodes1d:             number of uniformly spaced nodes in 1 dimension\nnumberquadraturepoints1d:  number of Gauss-Legendre quadrature points in 1 dimension\nnumbercomponents:          number of components\ndimension:                 dimension of basis\n\nReturns:\n\nH1 Lagrange tensor product basis on uniformly spaced nodes object\n\nExample:\n\n# generate H1 Lagrange tensor product basis on uniformly spaced nodes\nbasis = TensorH1UniformBasis(4, 3, 2, 1);\n\n# verify\nprintln(basis)\n\n# output\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 3\n    numbercomponents: 2\n    dimension: 1\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#Macro-Element-Bases","page":"-","title":"Macro-Element Bases","text":"","category":"section"},{"location":"public/basis/","page":"-","title":"-","text":"These bases represent a macro-element consisting of multiple overlapping micro elements, where the micro elements are created as above.","category":"page"},{"location":"public/basis/","page":"-","title":"-","text":"TensorH1LagrangeMacroBasis\nTensorH1UniformMacroBasis","category":"page"},{"location":"public/basis/#LFAToolkit.TensorH1LagrangeMacroBasis","page":"-","title":"LFAToolkit.TensorH1LagrangeMacroBasis","text":"TensorH1LagrangeMacroBasis(\n    numbernodes1d,\n    numberquadraturepoints1d,\n    numbercomponents,\n    dimension,\n    numberelements1d,\n    collocatedquadrature = false,\n)\n\nTensor product macro-element basis on Gauss-Legendre-Lobatto points with   Gauss-Legendre (default) or Gauss-Legendre-Lobatto quadrature points\n\nArguments:\n\nnumbernodes1d:                 number of Gauss-Legendre-Lobatto nodes in 1 dimension\nnumberquadraturepoints1d:      number of quadrature points in 1 dimension\nnumbercomponents:              number of components\ndimension:                     dimension of basis\nnumberelements1d:              number of elements in macro-element\n\nKeyword Arguments:\n\ncollocatedquadrature = false:  Gauss-Legendre or Gauss-Legendre-Lobatto quadrature points,                                    default: false, Gauss-Legendre-Lobatto\n\nReturns:\n\nH1 Lagrange tensor product macro-element basis object\n\nExample:\n\n# generate H1 Lagrange tensor macro-element product basis\nbasis = TensorH1LagrangeMacroBasis(4, 4, 1, 2, 2);\n\n# generate basis with Gauss-Legendre quadrature points\nbasis = TensorH1LagrangeMacroBasis(4, 4, 1, 2, 2; collocatedquadrature=true);\n\n# verify\nprintln(basis)\n\n# output\nmacro-element tensor product basis:\n    numbernodes1d: 7\n    numberquadraturepoints1d: 8\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#LFAToolkit.TensorH1UniformMacroBasis","page":"-","title":"LFAToolkit.TensorH1UniformMacroBasis","text":"TensorH1UniformMacroBasis(\n    numbernodes1d,\n    numberquadraturepoints1d,\n    numbercomponents,\n    dimension,\n    numberelements1d,\n)\n\nTensor product macro-element basis on uniformly points with Gauss-Legendre quadrature\n\nArguments:\n\nnumbernodes1d:             number of uniformly spaced nodes in 1 dimension\nnumberquadraturepoints1d:  number of Gauss-Legendre quadrature points in 1 dimension\nnumbercomponents:          number of components\ndimension:                 dimension of basis\nnumberelements1d:          number of elements in macro-element\n\nReturns:\n\nH1 Lagrange tensor product macro-element basis on uniformly space nodes object\n\nExample:\n\n# generate H1 Lagrange tensor product macro-element basis on uniformly spaced nodes\nbasis = TensorH1UniformMacroBasis(4, 3, 1, 2, 2);\n\n# verify\nprintln(basis)\n\n# output\nmacro-element tensor product basis:\n    numbernodes1d: 7\n    numberquadraturepoints1d: 6\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#P-Prolongation-Basis","page":"-","title":"P Prolongation Basis","text":"","category":"section"},{"location":"public/basis/","page":"-","title":"-","text":"This basis provides prolongation from a single element to a single element of higher order.","category":"page"},{"location":"public/basis/","page":"-","title":"-","text":"TensorH1LagrangePProlongationBasis","category":"page"},{"location":"public/basis/#LFAToolkit.TensorH1LagrangePProlongationBasis","page":"-","title":"LFAToolkit.TensorH1LagrangePProlongationBasis","text":"TensorH1LagrangePProlongationBasis(\n    numbercoarsenodes1d,\n    numberfinenodes1d,\n    numbercomponents,\n    dimension,\n)\n\nTensor product p-prolongation basis on Gauss-Legendre-Lobatto points\n\nArguments:\n\nnumbercoarsenodes1d:  number of coarse grid Gauss-Legendre-Lobatto nodes in 1 dimension\nnumberfinenodes1d:    number of fine grid Gauss-Legendre-Lobatto nodes in 1 dimension\nnumbercomponents:     number of components\ndimension:            dimension of basis\n\nReturns:\n\nH1 Lagrange tensor product p-prolongation basis object\n\nExample:\n\n# generate H1 Lagrange tensor product p-prolongation basis\nbasisctof = TensorH1LagrangePProlongationBasis(2, 3, 1, 2);\n\n# verify\nprintln(basisctof)\n\n# output\ntensor product basis:\n    numbernodes1d: 2\n    numberquadraturepoints1d: 3\n    numbercomponents: 1\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#H-Prolongation-Bases","page":"-","title":"H Prolongation Bases","text":"","category":"section"},{"location":"public/basis/","page":"-","title":"-","text":"These bases provide prolongation from a single element to a macro-element of the same order or a macro-element to a macro-element with a larger number of elements.","category":"page"},{"location":"public/basis/","page":"-","title":"-","text":"TensorH1LagrangeHProlongationBasis\nTensorH1UniformHProlongationBasis\nTensorH1LagrangeHProlongationMacroBasis\nTensorH1UniformHProlongationMacroBasis","category":"page"},{"location":"public/basis/#LFAToolkit.TensorH1LagrangeHProlongationBasis","page":"-","title":"LFAToolkit.TensorH1LagrangeHProlongationBasis","text":"TensorH1LagrangeHProlongationBasis(\n    numbernodes1d,\n    numbercomponents,\n    dimension,\n    numberfineelements1d,\n)\n\nTensor product h-prolongation basis on Gauss-Legendre-Lobatto points\n\nArguments:\n\nnumbernodes1d:         number of Gauss-Legendre-Lobatto nodes in 1 dimension per element\nnumbercomponents:      number of components\ndimension:             dimension of basis\nnumberfineelements1d:  number of fine grid elements\n\nReturns:\n\nH1 Lagrange tensor product h-prolongation basis object\n\nExample:\n\n# generate H1 Lagrange tensor product h-prolongation basis\nbasis = TensorH1LagrangeHProlongationBasis(4, 3, 2, 2);\n\n# verify\nprintln(basis)\n\n# output\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 7\n    numbercomponents: 3\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#LFAToolkit.TensorH1UniformHProlongationBasis","page":"-","title":"LFAToolkit.TensorH1UniformHProlongationBasis","text":"TensorH1UniformHProlongationBasis(\n    numbernodes1d,\n    numbercomponents,\n    dimension,\n    numberfineelements1d,\n)\n\nTensor product h-prolongation basis on uniformly spaced points\n\nArguments:\n\nnumbernodes1d:         number of uniformly spaced nodes per element\nnumbercomponents:      number of components\ndimension:             dimension of basis\nnumberfineelements1d:  number of fine grid elements\n\nReturns:\n\nH1 Lagrange tensor product h-prolongation basis on uniformly spaced nodes object\n\nExample:\n\n# generate H1 Lagrange tensor product h-prolongation basis on uniformly spaced nodes\nbasis = TensorH1UniformHProlongationBasis(4, 3, 2, 2);\n\n# verify\nprintln(basis)\n\n# output\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 7\n    numbercomponents: 3\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#LFAToolkit.TensorH1LagrangeHProlongationMacroBasis","page":"-","title":"LFAToolkit.TensorH1LagrangeHProlongationMacroBasis","text":"TensorH1LagrangeHProlongationMacroBasis(\n    numbernodes1d,\n    numbercomponents,\n    dimension,\n    numbercoarseelements1d,\n    numberfineelements1d,\n)\n\nTensor product macro-element h-prolongation basis on Gauss-Legendre-Lobatto points\n\nArguments:\n\nnumbernodes1d:           number of Gauss-Legendre-Lobatto nodes in 1 dimension per element\nnumbercomponents:        number of components\ndimension:               dimension of basis\nnumbercoarseelements1d:  number of coarse grid elements in macro-element\nnumberfineelements1d:    number of fine grid elements in macro-element\n\nReturns:\n\nH1 Lagrange tensor product h-prolongation macro-element basis object\n\nExample:\n\n# generate H1 Lagrange tensor product h-prolongation macro-element basis\nbasis = TensorH1LagrangeHProlongationMacroBasis(4, 1, 2, 2, 4);\n\n# verify\nprintln(basis)\n\n# output\nmacro-element tensor product basis:\n    numbernodes1d: 7\n    numberquadraturepoints1d: 13\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#LFAToolkit.TensorH1UniformHProlongationMacroBasis","page":"-","title":"LFAToolkit.TensorH1UniformHProlongationMacroBasis","text":"TensorH1UniformHProlongationMacroBasis(\n    numbernodes1d,\n    numbercomponents,\n    dimension,\n    numbercoarseelements1d,\n    numberfineelements1d,\n)\n\nTensor product macro-element h-prolongation basis on uniformly spaced points\n\nArguments:\n\nnumbernodes1d:           number of uniformly spaced nodes per element\nnumbercomponents:        number of components\ndimension:               dimension of basis\nnumbercoarseelements1d:  number of coarse grid elements in macro-element\nnumberfineelements1d:    number of fine grid elements in macro-element\n\nReturns:\n\nH1 Lagrange tensor product h-prolongation macro-element basis on uniformly spaced nodes object\n\nExample:\n\n# generate H1 Lagrange tensor product h-prolongation macro-element basis on uniformly spaced nodes\nbasis = TensorH1UniformHProlongationMacroBasis(4, 1, 2, 2, 4);\n\n# verify\nprintln(basis)\n\n# output\nmacro-element tensor product basis:\n    numbernodes1d: 7\n    numberquadraturepoints1d: 13\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/operatorfield/#Operator-Field","page":"-","title":"Operator Field","text":"","category":"section"},{"location":"public/operatorfield/","page":"-","title":"-","text":"The operator field object represents the different inputs and outputs for the finite element operator weak form. In a Galerkin operator, inputs represent the finite element basis for unknown values and the basis evaluation modes, while the outputs represent the finite element basis for the test functions and their basis evaluation modes.","category":"page"},{"location":"public/operatorfield/","page":"-","title":"-","text":"OperatorField","category":"page"},{"location":"public/operatorfield/#LFAToolkit.OperatorField","page":"-","title":"LFAToolkit.OperatorField","text":"OperatorField(\n    basis,\n    evaluationmodes\n)\n\nFinite Element operator input or output, with a basis and evaluation mode\n\nArguments:\n\nbasis:            finite element basis for the field\nevaluationmodes:  array of basis evaluation modes,                         note that quadrature weights must be listed in a                         separate operator field\n\nReturns:\n\nFinite element operator field object\n\nExample:\n\n# basis\nbasis = TensorH1LagrangeBasis(4, 3, 2, 1);\n\n# quadrature weights field, input only\nweightsfield = OperatorField(basis, [EvaluationMode.quadratureweights], \"quadrature weights\");\n\n# verify\nprintln(weightsfield)\n\n# input or output field\ninputfield = OperatorField(basis, [\n    EvaluationMode.interpolation,\n    EvaluationMode.gradient,\n    ],\n    \"gradient of weak form input\"\n);\n\n# verify\nprintln(inputfield)\n\n# output\noperator field:\n  name:\n    quadrature weights \n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 3\n    numbercomponents: 2\n    dimension: 1\n  evaluation mode:\n    quadratureweights\noperator field:\n  name:\n    gradient of weak form input\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 3\n    numbercomponents: 2\n    dimension: 1\n  evaluation modes:\n    interpolation\n    gradient\n\n\n\n\n\n","category":"type"},{"location":"release_notes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"release_notes/#Current-Development","page":"Release Notes","title":"Current Development","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Current development includes:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Enhancements:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Added conformal maps sausage_transformation, kosloff_talezer_transformation, and hale_trefethen_strip_transformation for basis quadrature spaces.\nAdd advection operator convenience constructor and examples.","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Bugfixes:","category":"page"},{"location":"release_notes/#v0.5.0","page":"Release Notes","title":"v0.5.0","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"This release include some minor fixes and some convenience utilities.","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Breaking change:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Keyword argument indicating quadrature point placement for Basis convenience constructors renamed.","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Enhancements:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Added computesymbolsoverrange to facilitate common analysis.","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Bugfixes:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Fix language surrounding quadrature, consistently using Gauss-Legendre and Gauss-Legendre-Lobatto or gaussquadrature and gausslobattoquadrature.","category":"page"},{"location":"release_notes/#v0.4.1","page":"Release Notes","title":"v0.4.1","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"This release includes a small fix for properly handling stretched meshes, such as when dx != dy.","category":"page"},{"location":"release_notes/#v0.4.0","page":"Release Notes","title":"v0.4.0","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"This release includes improved functionality and bugfixes.","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Enhancements:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Added relaxation parameter for application of BDDC preconditioners","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Bugfixes:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Minor spelling and notation errors corrected\nNewton tolerance for quadrature point computation relaxed\nIdentity preconditioner modified for compatibility with multigrid\nFix computation of change of coordinates for gradient and quadrature weights\nFix computation of eigenvalue estimates and error iteration for Chebyshev smoother\nFix injection operator for Dirichlet BDDC","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Examples:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Added linear elasticity example, renumbered Neo-Hookean hyperelasticity example","category":"page"},{"location":"release_notes/#v0.3.0","page":"Release Notes","title":"v0.3.0","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"This release includes updated functionality and an interface change.","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Breaking change:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Refactor GalleryOperator; now GalleryVectorOperator and GalleryMacroElementOperator included","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Functionality improvement:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Initial implementations of lumped and Dirichlet BDDC preconditioners added","category":"page"},{"location":"release_notes/#v0.2.2","page":"Release Notes","title":"v0.2.2","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Relax compatibility requirement to Julia 1.3 - 1.6.","category":"page"},{"location":"release_notes/#v0.2.1","page":"Release Notes","title":"v0.2.1","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Minor bugfixes:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Gauss and Gauss-Lobatto node computation tolerances relaxed\nTypo fixes\nsrc directory reorganized to better support future development","category":"page"},{"location":"release_notes/#v0.2","page":"Release Notes","title":"v0.2","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"This release includes updated functionality and an improved interface.","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Functionality updates include:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Macro-element bases consisting of multiple micro-elements\nChebyshev preconditioning analysis\nH-multigrid analysis","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Interface improvements include:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Multi-component basis support simplified","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Additional changes include:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Improved documentation\nExpanded examples, to include Neo-Hookean hyperelasticity\nRename primary branch to main","category":"page"},{"location":"release_notes/#v0.1.1","page":"Release Notes","title":"v0.1.1","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Minor bugfixes.","category":"page"},{"location":"release_notes/#v0.1","page":"Release Notes","title":"v0.1","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"This release includes initial basic functionality of LFAToolkit.jl.","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Functionality includes:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"User defined second order PDEs\nArbitrary basis order, dimension, and number of components\nIndependent mesh scaling in each dimension\nJacobi preconditioning analysis\nP-multigrid analysis","category":"page"},{"location":"public/operator/#Finite-Element-Operator","page":"-","title":"Finite Element Operator","text":"","category":"section"},{"location":"public/operator/","page":"-","title":"-","text":"The finite element operator object provides the action of the user provide weak form on the given mesh and finite element bases. This weak form follows the representation given in [2].","category":"page"},{"location":"public/operator/#Examples","page":"-","title":"Examples","text":"","category":"section"},{"location":"public/operator/","page":"-","title":"-","text":"This is an example of a scalar mass operator in two dimensions.","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex001_mass.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"Plot for the symbol of the finite element operator for the 2D scalar mass problem with cubic basis.","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"This is an example of a scalar diffusion operator in two dimensions.","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex002_diffusion.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"Plot for the symbol of the finite element operator for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"public/operator/#Documentation","page":"-","title":"Documentation","text":"","category":"section"},{"location":"public/operator/","page":"-","title":"-","text":"The finite element operator can be defined from a user defined weak form or from the gallery of weak forms for select PDEs.","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"Operator\ncomputesymbols(::Operator, ::Array)","category":"page"},{"location":"public/operator/#LFAToolkit.Operator","page":"-","title":"LFAToolkit.Operator","text":"Operator(\n    weakform,\n    mesh,\n    inputs,\n    outputs\n)\n\nFinite element operator comprising of a weak form and bases\n\nArguments:\n\nweakform:  user provided function that represents weak form at                  quadrature points\nmesh:      mesh object with deformation in each dimension\ninputs:    array of operator input fields\noutputs:   array of operator output fields\n\nReturns:\n\nFinite element operator object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nbasis = TensorH1LagrangeBasis(4, 4, 1, 2);\n\nfunction massweakform(u::Array{Float64}, w::Array{Float64})\n    v = u*w[1]\n    return [v]\nend\n\n# mass operator\ninputs = [\n    OperatorField(basis, [EvaluationMode.interpolation]),\n    OperatorField(basis, [EvaluationMode.quadratureweights]),\n];\noutputs = [OperatorField(basis, [EvaluationMode.interpolation])];\nmass = Operator(massweakform, mesh, inputs, outputs);\n\n# verify\nprintln(mass)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\n\n\n\n\n\n","category":"type"},{"location":"public/operator/#LFAToolkit.computesymbols-Tuple{Operator, Array}","page":"-","title":"LFAToolkit.computesymbols","text":"computesymbols(operator, θ)\n\nCompute the symbol matrix for an operator\n\nArguments:\n\noperator:  finite element operator to compute symbol matrix for\nθ:         Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the operator\n\nExample:\n\nusing LinearAlgebra;\n\nfor dimension in 1:3\n    # setup\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(1.0);\n    elseif dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    diffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n    # compute symbols\n    A = computesymbols(diffusion, π*ones(dimension));\n\n    # verify\n    eigenvalues = real(eigvals(A));\n    if dimension == 1\n        @assert minimum(eigenvalues) ≈ 1\n        @assert maximum(eigenvalues) ≈ 4/3\n    elseif dimension == 2\n        @assert minimum(eigenvalues) ≈ 2/3\n        @assert maximum(eigenvalues) ≈ 64/45\n    elseif dimension == 3\n        @assert minimum(eigenvalues) ≈ 1/3\n        @assert maximum(eigenvalues) ≈ 256/225\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"public/operatorgallery/#Finite-Element-Operator-Gallery","page":"-","title":"Finite Element Operator Gallery","text":"","category":"section"},{"location":"public/operatorgallery/","page":"-","title":"-","text":"The following PDEs are available in the operator gallery.","category":"page"},{"location":"public/operatorgallery/#Scalar-Mass,-Diffusion,-Advection,-and-SUPG-Advection-Operators","page":"-","title":"Scalar Mass, Diffusion, Advection, and SUPG Advection Operators","text":"","category":"section"},{"location":"public/operatorgallery/","page":"-","title":"-","text":"GalleryOperator","category":"page"},{"location":"public/operatorgallery/#LFAToolkit.GalleryOperator","page":"-","title":"LFAToolkit.GalleryOperator","text":"GalleryOperator(\n    name,\n    numbernodes1d,\n    numberquadraturepoints1d,\n    mesh;\n    collocatedquadrature = false,\n    mapping = nothing,\n    parameters = nothing\n)\n\nFinite element operator from a gallery of options\n\nArguments:\n\nname:                      string containing name of operator\nnumbernodes1d:             polynomial order of TensorH1LagrangeBasis\nnumberquadraturepoints1d:  number of quadrature points in one dimension for basis\nmesh:                      mesh for operator\n\nKeyword Arguments:\n\ncollocatedquadrature = false:  Gauss-Legendre or Gauss-Legendre-Lobatto quadrature points,                                      default: false, Gauss-Legendre-Lobatto\nmapping = nothing:             quadrature point mapping - sausage, Kosloff-Talezer,                                      or Hale-Trefethen strip transformation                                      default: nothing, no transformation\nparameters = nothing:          named tuple of model parameters                                      default: nothing, default parameters\n\nReturns:\n\nFinite element operator object\n\nMass matrix example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# verify\nprintln(mass)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\n\nDiffusion operator example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\ndiffusion = GalleryOperator(\"diffusion\", 4, 4, mesh);\n\n# verify\nprintln(diffusion)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\n\nAdvection operator example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nadvection = GalleryOperator(\"advection\", 4, 4, mesh);\n\n# verify\nprintln(advection)\n\n# output\n\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\n\nSUPG mass matrix example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nparameters = (wind = [1., 1.], τ = 1.0);\nmapping = nothing;\ncollocate = false;\nsupgmass = GalleryOperator(\"supgmass\", 4, 4, mesh, parameters = parameters, collocatedquadrature = collocate, mapping = mapping);\n\n# verify\nprintln(supgmass)\n\n# output\n\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation modes:\n    interpolation\n    gradient\n\nSUPG advection operator example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nparameters = nothing;\nmapping = nothing;\ncollocate = false;\nsupgadvection = GalleryOperator(\"supgadvection\", 4, 4, mesh, parameters = parameters, collocatedquadrature = collocate, mapping = mapping);\n\n# verify\nprintln(supgadvection)\n\n# output\n\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation modes:\n    interpolation\n    gradient\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"public/operatorgallery/#Vector-Mass-and-Diffusion-Operators","page":"-","title":"Vector Mass and Diffusion Operators","text":"","category":"section"},{"location":"public/operatorgallery/","page":"-","title":"-","text":"GalleryVectorOperator","category":"page"},{"location":"public/operatorgallery/#LFAToolkit.GalleryVectorOperator","page":"-","title":"LFAToolkit.GalleryVectorOperator","text":"GalleryVectorOperator(name, numbernodes1d, numberquadraturepoints1d, numberelements1d, mesh)\n\nFinite element operator from a gallery of options\n\nArguments:\n\nname:                      string containing name of operator\nnumbernodes1d:             polynomial order of TensorH1LagrangeBasis\nnumberquadraturepoints1d:  number of quadrature points in one dimension for basis\nnumbercomponents:          number of components\nmesh:                      mesh for operator\n\nReturns:\n\nFinite element operator object\n\nMass matrix example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryVectorOperator(\"mass\", 4, 4, 3, mesh);\n\n# verify\nprintln(mass)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 3\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 3\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 3\n    dimension: 2\n  evaluation mode:\n    interpolation\n\nDiffusion operator example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\ndiffusion = GalleryVectorOperator(\"diffusion\", 4, 4, 3, mesh);\n\n# verify\nprintln(diffusion)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 3\n    dimension: 2\n  evaluation mode:\n    gradient\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 3\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 3\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"public/operatorgallery/#Scalar-Macro-Element-Mass-and-Diffusion-Operators","page":"-","title":"Scalar Macro-Element Mass and Diffusion Operators","text":"","category":"section"},{"location":"public/operatorgallery/","page":"-","title":"-","text":"GalleryMacroElementOperator","category":"page"},{"location":"public/operatorgallery/#LFAToolkit.GalleryMacroElementOperator","page":"-","title":"LFAToolkit.GalleryMacroElementOperator","text":"GalleryMacroElementOperator(\n    name,\n    numbernodes1d,\n    numberquadraturepoints1d,\n    numberelements1d,\n    mesh;\n    parameters = nothing,\n)\n\nFinite element operator from a gallery of options\n\nArguments:\n\nname:                      string containing name of operator\nnumbernodes1d:             polynomial order of TensorH1LagrangeBasis\nnumberquadraturepoints1d:  number of quadrature points in one dimension for basis\nnumberelements1d:          number of elements in macro-element\nmesh:                      mesh for operator\n\nKeyword Arguments:\n\nparameters = nothing:      named tuple of model parameters                                  default: nothing, default parameters\n\nReturns:\n\nFinite element operator object\n\nMass matrix example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryMacroElementOperator(\"mass\", 4, 4, 2, mesh);\n\n# verify\nprintln(mass)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  macro-element tensor product basis:\n    numbernodes1d: 7\n    numberquadraturepoints1d: 8\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  macro-element tensor product basis:\n    numbernodes1d: 7\n    numberquadraturepoints1d: 8\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  macro-element tensor product basis:\n    numbernodes1d: 7\n    numberquadraturepoints1d: 8\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n  evaluation mode:\n    interpolation\n\nDiffusion operator example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\ndiffusion = GalleryMacroElementOperator(\"diffusion\", 4, 4, 2, mesh);\n\n# verify\nprintln(diffusion)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  macro-element tensor product basis:\n    numbernodes1d: 7\n    numberquadraturepoints1d: 8\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n  evaluation mode:\n    gradient\noperator field:\n  macro-element tensor product basis:\n    numbernodes1d: 7\n    numberquadraturepoints1d: 8\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  macro-element tensor product basis:\n    numbernodes1d: 7\n    numberquadraturepoints1d: 8\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n  evaluation mode:\n    gradient\n\nAdvection operator example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nadvection = GalleryVectorOperator(\"advection\", 4, 4, 1, mesh);\n\n# verify\nprintln(advection)\n\n# output\n\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"public/evaluationmode/#Basis-Evaluation-Mode","page":"-","title":"Basis Evaluation Mode","text":"","category":"section"},{"location":"public/evaluationmode/","page":"-","title":"-","text":"This enum lists the supported basis evaluation modes for finite element operator fields. Note that the quadrature weights evaluation mode can only be used in an input field.","category":"page"},{"location":"public/evaluationmode/","page":"-","title":"-","text":"EvaluationMode.EvalMode","category":"page"},{"location":"public/evaluationmode/#LFAToolkit.EvaluationMode.EvalMode","page":"-","title":"LFAToolkit.EvaluationMode.EvalMode","text":"Basis evaluation mode for operator inputs and outputs\n\nModes:\n\ninterpolation:      values interpolated to quadrature points\ngradient:           derivatives evaluated at quadrature points\nquadratureweights:  quadrature weights\n\nExample:\n\nEvaluationMode.EvalMode\n\n# output\nEnum LFAToolkit.EvaluationMode.EvalMode:\ninterpolation = 0\ngradient = 1\nquadratureweights = 2\n\n\n\n\n\n","category":"type"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section documents the LFAToolkit examples.","category":"page"},{"location":"examples/#Contents","page":"Examples","title":"Contents","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages = [\n    \"examples/advection.md\",\n    \"examples/advection_supg.md\",\n    \"examples/diffusion.md\",\n    \"examples/linear_elasticity.md\",\n    \"examples/hyperelasticity.md\",\n]","category":"page"},{"location":"examples/diffusion/#Diffusion-operator","page":"-","title":"Diffusion operator","text":"","category":"section"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of various preconditioners for the 2D scalar diffusion problem.","category":"page"},{"location":"examples/diffusion/#Problem-formulation","page":"-","title":"Problem formulation","text":"","category":"section"},{"location":"examples/diffusion/","page":"-","title":"-","text":"The scalar diffusion problem is given by","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"nabla^2 u = f","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"with a weak form of","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"int_Omega nabla u nabla v = int_Omega v f forall v in V","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"for an appropriate test space V subseteq H_0^1 left( Omega right) on the domain. In this weak formulation, boundary terms have been omitted, as they are not present on the infinite grid for Local Fourier Analysis.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"Plot for the symbol of the finite element operator for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"examples/diffusion/#LFAToolkit-code","page":"-","title":"LFAToolkit code","text":"","category":"section"},{"location":"examples/diffusion/","page":"-","title":"-","text":"The diffusion operator is the classical test case for multigrid preconditioners and solvers.","category":"page"},{"location":"examples/diffusion/#Jacobi","page":"-","title":"Jacobi","text":"","category":"section"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of a Jacobi smoother.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex101_jacobi.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"Plot for the symbol of a Jacobi smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"examples/diffusion/#Chebyshev","page":"-","title":"Chebyshev","text":"","category":"section"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of a Chebyshev smoother.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex111_chebyshev.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"Plot for the symbol of a cubic Chebyshev smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"examples/diffusion/#P-Multigrid","page":"-","title":"P-Multigrid","text":"","category":"section"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of a two level p-multigrid preconditioner.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex201_pmultigrid.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"Example plot for the symbol of p-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of a multilevel p-multigrid preconditioner.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex202_pmultigrid_multilevel.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"Example plot for the symbol of multilevel p-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"examples/diffusion/#H-Multigrid","page":"-","title":"H-Multigrid","text":"","category":"section"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of a two level h-multigrid preconditioner.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex211_hmultigrid.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"Example plot for the symbol of h-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with linear basis.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of a multilevel h-multigrid preconditioner.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex212_hmultigrid_multilevel.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"Example plot for the symbol of multilevel h-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with linear basis.","category":"page"},{"location":"examples/diffusion/#Lumped-BDDC","page":"-","title":"Lumped BDDC","text":"","category":"section"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of a simple lumped BDDC preconditioner.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex221_lumped_bddc.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of a simple Dirichlet BDDC preconditioner.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex223_dirichlet_bddc.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"This section documents the public API of the LFAToolkit.","category":"page"},{"location":"public/#Contents","page":"Public API","title":"Contents","text":"","category":"section"},{"location":"public/#Finite-Element-Operators","page":"Public API","title":"Finite Element Operators","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Pages = [\n    \"public/mesh.md\",\n    \"public/basis.md\",\n    \"public/evaluationmode.md\",\n    \"public/operatorfield.md\",\n    \"public/operator.md\",\n    \"public/operatorgallery.md\",\n]","category":"page"},{"location":"public/#Preconditioners","page":"Public API","title":"Preconditioners","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Pages = [\n    \"public/pc/identity.md\",\n    \"public/pc/jacobi.md\",\n    \"public/pc/chebyshev.md\",\n    \"public/pc/multigrid.md\",\n    \"public/pc/bddc.md\",\n]","category":"page"},{"location":"public/#Utilities","page":"Public API","title":"Utilities","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Pages = [\n    \"public/utilities.md\",\n]","category":"page"},{"location":"public/pc/bddc/#Preconditioner:-BDDC","page":"-","title":"Preconditioner: BDDC","text":"","category":"section"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"LFAToolkit supports lumped and Dirichlet BDDC preconditioners.","category":"page"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"BDDCInjectionType.BDDCInjectType","category":"page"},{"location":"public/pc/bddc/#LFAToolkit.BDDCInjectionType.BDDCInjectType","page":"-","title":"LFAToolkit.BDDCInjectionType.BDDCInjectType","text":"BDDC injection types\n\nTypes:\n\nscaled:    scaled injection\nharmonic:  discrete harmonic extension\n\nExample\n\nLFAToolkit.BDDCInjectionType.BDDCInjectType\n\n# output\nEnum LFAToolkit.BDDCInjectionType.BDDCInjectType:\nscaled = 0\nharmonic = 1\n\n\n\n\n\n","category":"type"},{"location":"public/pc/bddc/#Lumped-BDDC","page":"-","title":"Lumped BDDC","text":"","category":"section"},{"location":"public/pc/bddc/#Examples","page":"-","title":"Examples","text":"","category":"section"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"This is an example of a simple lumped BDDC preconditioner.","category":"page"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex221_lumped_bddc.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"This is an example of a simple lumped BDDC preconditioner on a macro-element patch.","category":"page"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex222_lumped_bddc.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/bddc/#Documentation","page":"-","title":"Documentation","text":"","category":"section"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"LumpedBDDC\ncomputesymbols(::BDDC, ::Array, ::Array)","category":"page"},{"location":"public/pc/bddc/#LFAToolkit.LumpedBDDC","page":"-","title":"LFAToolkit.LumpedBDDC","text":"LumpedBDDC(operator)\n\nLumped BDDC preconditioner for finite element operators\n\nArguments:\n\noperator:  finite element operator to precondition\n\nReturns:\n\nLumped BDDC preconditioner object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\n\n# operator\nfinediffusion = GalleryOperator(\"diffusion\", 5, 5, mesh);\n\n# preconditioner\nbddc = LumpedBDDC(finediffusion);\n\n# verify\nprintln(bddc)\nprintln(bddc.operator)\n\n# output\nlumped BDDC preconditioner\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 5\n    numberquadraturepoints1d: 5\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\noperator field:\n  tensor product basis:\n    numbernodes1d: 5\n    numberquadraturepoints1d: 5\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 5\n    numberquadraturepoints1d: 5\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"public/pc/bddc/#LFAToolkit.computesymbols-Tuple{BDDC, Array, Array}","page":"-","title":"LFAToolkit.computesymbols","text":"computesymbols(bddc, θ)\n\nCompute the symbol matrix for a BDDC preconditioned operator\n\nArguments:\n\nbddc:  BDDC preconditioner to compute symbol matrix for\nθ:     Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the BDDC preconditioned operator\n\nLumped BDDC Example:\n\nusing LinearAlgebra;\n\nfor dimension in 2:3\n    # setup\n    mesh = []\n    if dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    diffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n    bddc = LumpedBDDC(diffusion)\n\n    # compute symbols\n    A = computesymbols(bddc, [0.2], π*ones(dimension));\n\n    # verify\n    eigenvalues = real(eigvals(A));\n    if dimension == 2\n        @assert minimum(eigenvalues) ≈ 0.43999999999999995\n        @assert maximum(eigenvalues) ≈ 0.8\n    elseif dimension == 3\n        @assert minimum(eigenvalues) ≈ -0.6319999999999972\n        @assert maximum(eigenvalues) ≈ 0.8\n    end\nend\n\n# output\n\n\nDirichlet BDDC Example:\n\nusing LinearAlgebra;\n\nfor dimension in 2:3\n    # setup\n    mesh = []\n    if dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    diffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n    bddc = DirichletBDDC(diffusion)\n\n    # compute symbols\n    A = computesymbols(bddc, [0.2], π*ones(dimension));\n\n    # verify\n    eigenvalues = real(eigvals(A));\n    if dimension == 2\n        @assert minimum(eigenvalues) ≈ 0.7999999999999998\n        @assert maximum(eigenvalues) ≈ 0.8\n    elseif dimension == 3\n        @assert minimum(eigenvalues) ≈ 0.7801226993865031\n        @assert maximum(eigenvalues) ≈ 0.8\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"public/pc/bddc/#Dirichlet-BDDC","page":"-","title":"Dirichlet BDDC","text":"","category":"section"},{"location":"public/pc/bddc/#Examples-2","page":"-","title":"Examples","text":"","category":"section"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"This is an example of a simple Dirichlet BDDC preconditioner.","category":"page"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex223_dirichlet_bddc.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"This is an example of a simple Dirichlet BDDC preconditioner on a macro-element patch.","category":"page"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex224_dirichlet_bddc.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/bddc/#Documentation-2","page":"-","title":"Documentation","text":"","category":"section"},{"location":"public/pc/bddc/","page":"-","title":"-","text":"DirichletBDDC","category":"page"},{"location":"public/pc/bddc/#LFAToolkit.DirichletBDDC","page":"-","title":"LFAToolkit.DirichletBDDC","text":"DirichletBDDC(operator)\n\nDirichlet BDDC preconditioner for finite element operators\n\nArguments:\n\noperator:  finite element operator to precondition\n\nReturns:\n\nDirichlet BDDC preconditioner object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\n\n# operator\nfinediffusion = GalleryOperator(\"diffusion\", 5, 5, mesh);\n\n# preconditioner\nbddc = DirichletBDDC(finediffusion);\n\n# verify\nprintln(bddc)\nprintln(bddc.operator)\n\n# output\nDirichlet BDDC preconditioner\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 5\n    numberquadraturepoints1d: 5\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\noperator field:\n  tensor product basis:\n    numbernodes1d: 5\n    numberquadraturepoints1d: 5\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 5\n    numberquadraturepoints1d: 5\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"background/#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Local Fourier Analysis (LFA) was first used by Brandt [1] to analyze the convergence of multi-level adaptive techniques for solving PDEs discretized with finite differences, but the technique has been adapted for multi-level and multi-grid techniques using finite element discretizations. While this library focuses on the finite element discretizations, finite difference discretizations of PDEs can often be recovered from finite element formulations by using linear finite elements on a structured grid. This fact makes LFAToolkit.jl an extremely flexible tool for LFA.","category":"page"},{"location":"background/#Local-Fourier-Analysis","page":"Mathematical Background","title":"Local Fourier Analysis","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"LFA considers the local properties of the descretized system via its Fourier modes and the eigenvalues of the associated symbol matrix. We will describe the arbitrary degree, one dimensional scalar case and extend it to an arbitrary dimension and number of components finite element problem.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"First consider a scalar Toeplitz operator L_h on an infinite one dimensional uniform grid G_h, This operator is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"L_h mathrelhat= left s_kappa right_h left( kappa in V right)\nL_h w_h left( x right) = sum_kappa in V s_kappa w_h left( x + kappa h right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where V subset mathcalZ is a finite index set, s_kappa in mathcalR are constant coefficients and w_h left( x right) is a l^2 function on G_h.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"As L_h is Toeplitz, it can be diagonalized by the standard Fourier modes varphi left( theta x right) = e^imath theta x  h.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"If for all grid functions varphi left( theta x right) we have","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"L_h varphi left( theta x right) = tildeL_h left( theta right) varphi left( theta x right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"then tildeL_h left( theta right) = sum_kappa in V s_kappa e^imath theta kappa is the symbol of L_h.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"We can extend this to a p times p linear system of operators representing a scalar problem on a degree p finite element","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeL_h =\nbeginbmatrix\n    tildeL_h^1 1    cdots    tildeL_h^1 p  \n    vdots                vdots    vdots              \n    tildeL_h^p 1    cdots    tildeL_h^p p  \nendbmatrix","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where tildeL_h^i j is given by a scalar Toeplitz operator describing how component j appears in the equation for component i.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"The spectral radius of the symbol of an error propagation operator determines how rapidly a relaxation scheme decreases error at a target frequency for a given parameter value. In this context, low frequencies are given by theta in T^low = left - pi  2 pi  2 right) and high frequencies are given by theta in T^high = left - pi  2 3 pi  2 right) setminus T^low.","category":"page"},{"location":"background/#High-Order-Finite-Elements","page":"Mathematical Background","title":"High Order Finite Elements","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Consider the specific case of a Topeliz operator representing a scalar PDE in 1D with the weak formulation given by Brown in [2],","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"int_Omega v cdot f_0 left( u nabla u right) + nabla v  f_1 left( u nabla u right) = int_Omega f v forall v in V","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"for some suitable V subseteq H_0^1 left( Omega right). In this equation, cdot represents contraction over fields and  represents contraction over fields and spatial dimensions, both of which are omitted for the sake of clarity in this initial derivation. Boundary terms have been omitted, as they are not present on the infinite uniform grid G_h.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Selecting a finite element basis, we can discretize the weak form and produce","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"A u = b","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Using the algebraic representation of PDE operators discussed in [2], the PDE operator A is of the form","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"A = P^T A_e P","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"A_e = B^T D B","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where P represents the element assembly operator, B is a basis operator which computes the values and derivatives of the basis functions at the quadrature points, and D is a block diagonal operator which provides a pointwise application of the bilinear form on the quadrature points, to include quadrature weights and the change in coordinates between the physical and reference space.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"We can thus compute the symbol matrix as","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeA_h = Q^T left( A_e odot left e^imath left( x_j - x_i right) theta  h right right) Q","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where odot represents pointwise multiplication of the elements, h is the length of the element, and i j in leftlbrace 0 1 dots p rightrbrace. Q is a p + 1 times p matrix that localizes Fourier modes on an element.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Q =\nbeginbmatrix\n    I    \n    e_0  \nendbmatrix =\nbeginbmatrix\n    1         0         cdots    0       \n    0         1         cdots    0       \n    vdots    vdots    vdots    vdots  \n    0         0         cdots    1       \n    1         0         cdots    0       \nendbmatrix","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"This same computation of the symbol matrix extends to more complex PDE with multiple components and in higher dimensions.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Multiple components are supported by extending the p times p system of Toeplitz operators given above to a ncomp cdot p times ncomp cdot p system of operators.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Tensor products are used to extend this analysis into higher dimensions. The basis evaluation operators in higher dimensions are given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"B_interp2d = B_interp otimes B_interp\nB_grad2d =\nbeginbmatrix\n    B_grad otimes B_interp  \n    B_interp otimes B_grad  \nendbmatrix","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where B_interp and B_grad represent 1D basis interpolation and gradient operators, respectively.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Similarly, the localization of Fourier modes in higher dimensions is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Q_2d = Q otimes Q","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"and an analogous computation can be done for 3D.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Therefore, the symbol matrix for a PDE with arbitrary dimension, polynomial degree of basis, and number of components is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeA_h = Q^T left( A_e odot left e^imath left( mathbfx_j - mathbfx_i right) cdot boldsymboltheta  mathbfh right right) Q","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where odot represents pointwise multiplication of the elements, mathbfh is the length of the element in each dimension, and i j in leftlbrace 0 1 dots n cdot p^d rightrbrace. Q is a p - 1 times p matrix that localizes the Fourier modes on the element.","category":"page"},{"location":"background/#Multigrid","page":"Mathematical Background","title":"Multigrid","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Multigrid follows the following algorithm:","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"pre-smooth   : u_i = u_i + M^-1 left( b - A u_i right)\nrestrict     : r_c = R_ftoc left( b - A u_i right)\ncoarse solve : A_c e_c = r_c\nprolongate   : u_i = u_i + P_ctof e_c\npost-smooth  : u_i = u_i + M^-1 left( b - A u_i right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where f and c represent the fine and coarse grids, respectively, R_ftoc represents the grid restriction operator, P_ctof represents the grid prolongation operator.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"The total multigrid error propagation operator is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"M_TMG = S_f left( I - P_ctof A_c^-1 R_ftoc A_f right) S_f","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where S_f represents the error propagation operator for the smoother on the fine grid.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"This algorithm describes both h-multigrid and p-multigrid. While h-multigrid coarsens the mesh by increasing the size of each element, p-multigrid coarsens the mesh by decreasing the polynomial degree of the basis for each element.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"To explore the convergence of multigrid techniques, we need to analyze the symbol of the multigrid error propagation operator. We build the symbol of the p-multigrid error propagation operator in parts.","category":"page"},{"location":"background/#Smoothing-Operator","page":"Mathematical Background","title":"Smoothing Operator","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Multigrid techniques require error relaxation techniques. The error propagation operator for a relaxation technique is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"S = I - M^-1 A","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"In the specific case of Jacobi smoothing, M is given by M = diag left( A right).","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"The symbol of the error propagation operator is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeS_h left( omega theta right) = I - tildeM_h^-1 left( omega right) tildeA_h left( boldsymboltheta right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where omega is a relaxation parameter.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Specifically, for Jacobi we have","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeS_h left( omega boldsymboltheta right) = I - omega tildeM_h^-1 tildeA_h left( boldsymboltheta right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where omega is the weighting factor and tildeM_h is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeM_h = Q^T diag left( A_e right) Q","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"If multiple pre or post-smoothing passes are used, we have","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeS_h left( omega nu boldsymboltheta right) = left( I - tildeM_h^-1 left omega boldsymboltheta right) tildeA_h left( boldsymboltheta right) right)^nu","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where nu is the number of smoothing passes.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"More sophisticated smoothers can be used, such as the Chebyshev semi-iterative method. For discussion of the error propegation of the Chebyshev semi-iteative method, see Gutknecht and Röllin [3]. User defined smoothers are supported, where the user provides M^-1 or a function computing M^-1 based upon A, and tildeM^-1_h and tildeS_h are automatically generated and used inside the multigrid symbol matrix.","category":"page"},{"location":"background/#Grid-Transfer-Operators","page":"Mathematical Background","title":"Grid Transfer Operators","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"We consider grid transfer operators for p-type multigrid. The finite element operator for prolongation from the lower degree basis on the coarse grid to the high degree basis on the fine grid is given by ","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"P_ctof = P_f^T P_e P_c\nP_e = D_scale B_ctof","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where B_ctof is a basis interpolation from the coarse basis to the fine basis, P_f is the fine grid element assembly operator, P_c is the coarse grid element assembly operator, and D_scale is a scaling operator to account for node multiplicity across element interfaces.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Restriction from the fine grid to the coarse grid is given by the transpose, R_ftoc = P_ctof^T.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Thus, the symbol of P_ctof is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeP_ctof left( boldsymboltheta right) = Q_f^T left( left( D_scale B_ctof right) odot left e^imath left( mathbfx_j c - mathbfx_i f right) cdot boldsymboltheta  mathbfh right right) Q_c","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"and tildeR_ftoc is given by the analogous computation","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeR_ftoc left( theta right) = Q_c^T left( left( D_scale B_ctof right)^T odot left e^imath left( mathbfx_j f - mathbfx_i c right) boldsymboltheta  mathbfh right right) Q_f","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"The grid transfer operators for h-multgrid can be represented in a similar fashion by representing the fine grid as consisting of macro-elements that consist of multiple micro elements of the same polynomial degree as the coarse grid elements.","category":"page"},{"location":"background/#Multigrid-Error-Propagation-Symbol","page":"Mathematical Background","title":"Multigrid Error Propagation Symbol","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Combining these elements, the symbol of the error propagation operator for p-multigrid is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeE_TMG left( omega nu boldsymboltheta right) = tildeS_f left( omega nu boldsymboltheta right) left I - tildeP_ctof left( boldsymboltheta right) tildeA_c^-1 left( boldsymboltheta right) tildeR_ftoc left( boldsymboltheta right) tildeA_f left( boldsymboltheta right) right tildeS_f left( omega nu boldsymboltheta right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where tildeP_ctof and tildeR_ftoc are given above, tildeS_f is given by the smoothing operator, and tildeA_c and tildeA_f are derived from the PDE being analyzed.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"This can be extended to multi-level analysis by applying this analysis recursively, keeping in mind that tildeE_TMG is the symbol of the multigrid error propagation operator. The symbol of the multigrid operator is computed by noting that E = I - M A.","category":"page"},{"location":"#LFAToolkit","page":"Introduction","title":"LFAToolkit","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Local Fourier Analysis for arbitrary order finite element type operators","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Local Fourier Analysis (LFA) is a tool commonly used in the analysis of multigrid and multilevel algorithms for solving partial differential equations via finite element or finite difference methods. This analysis can be used to predict convergence rates and optimize parameters in multilevel methods and preconditioners.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This library provides a toolkit for analyzing the performance of preconditioners for arbitrary, user provided weak forms of partial differential equations. While this library focuses on the finite element discretizations, finite difference discretizations of PDEs can often be recovered from finite element formulations by using linear finite elements on a structured grid. This fact makes LFAToolkit.jl an extremely flexible tool for LFA.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Example plot for the symbol of p-multigrid with a Jacobi smoother for the 2D scalar diffusion problem.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"background.md\",\n    \"examples.md\",\n    \"public.md\",\n    \"private.md\",\n    \"release_notes.md\",\n    \"references.md\"\n]\nDepth = 1","category":"page"},{"location":"private/mesh/#Rectangular-Mesh","page":"-","title":"Rectangular Mesh","text":"","category":"section"},{"location":"private/mesh/","page":"-","title":"-","text":"LFAToolkit.Mesh","category":"page"},{"location":"private/mesh/#LFAToolkit.Mesh","page":"-","title":"LFAToolkit.Mesh","text":"Rectangular mesh with independent scaling in each dimesion\n\n\n\n\n\n","category":"type"}]
}
