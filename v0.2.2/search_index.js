var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A. Brandt, Multi-level adaptive solutions to boundary-value problems, Math. Comp., 31(138) (1977), pp. 33-390.","category":"page"},{"location":"references/","page":"References","title":"References","text":"J. Brown, Efficient nonlinear solvers for nodal high-order finite elements in 3D, Journal of Scientific Computing, 45 (2010), pp. 48-63.","category":"page"},{"location":"references/","page":"References","title":"References","text":"M. Gutknecht and S. Röllin,  The Chebyshev iteration revisited, Parallel Computing, 28 (2002), pp. 263-283.","category":"page"},{"location":"private/pc/chebyshev/#Preconditioner:-Chebyshev","page":"-","title":"Preconditioner: Chebyshev","text":"","category":"section"},{"location":"private/pc/chebyshev/","page":"-","title":"-","text":"LFAToolkit.getoperatordiagonalinverse(::Chebyshev)\nLFAToolkit.geteigenvalueestimates(::Chebyshev)","category":"page"},{"location":"private/pc/chebyshev/#LFAToolkit.getoperatordiagonalinverse-Tuple{Chebyshev}","page":"-","title":"LFAToolkit.getoperatordiagonalinverse","text":"getoperatordiagonalinverse(preconditioner)\n\nCompute or retrieve the inverse of the symbol matrix diagonal for a Chebyshev     preconditioner\n\nReturns:\n\nSymbol matrix diagonal inverse for the operator\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n# preconditioner\nchebyshev = Chebyshev(diffusion)\n\n# note: either syntax works\ndiagonalinverse = LFAToolkit.getoperatordiagonalinverse(chebyshev);\ndiagonalinverse = chebyshev.operatordiagonalinverse;\n\n# verify\n@assert diagonalinverse ≈ [3/14 0; 0 3/16]\n \n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/pc/chebyshev/#LFAToolkit.geteigenvalueestimates-Tuple{Chebyshev}","page":"-","title":"LFAToolkit.geteigenvalueestimates","text":"geteigenvalueestimates(preconditioner)\n\nCompute or retrieve the eigenvalue estimates for a Chebyshev preconditioner\n\nReturns:\n\nEigenvalue estimates for the operator\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n# preconditioner\nchebyshev = Chebyshev(diffusion)\n\n# estimate eigenvalues\neigenvalueestimates = LFAToolkit.geteigenvalueestimates(chebyshev);\n\n# verify\n@assert eigenvalueestimates ≈ [0, 15/7]\n \n# output\n\n\n\n\n\n\n","category":"method"},{"location":"public/mesh/#Rectangular-Mesh","page":"-","title":"Rectangular Mesh","text":"","category":"section"},{"location":"public/mesh/","page":"-","title":"-","text":"LFA is conducted on a infinite uniform grid. The mesh object allows the user to specify different scaling between the different dimensions of the mesh. This facilitates investigation of the smoothing and multigrid techniques on highly distorted meshes, such as boundary layer elements.","category":"page"},{"location":"public/mesh/","page":"-","title":"-","text":"Mesh1D\nMesh2D\nMesh3D","category":"page"},{"location":"public/mesh/#LFAToolkit.Mesh1D","page":"-","title":"LFAToolkit.Mesh1D","text":"Mesh1D(dx)\n\nOne dimensional regular background mesh\n\nArguments:\n\ndx: deformation in x dimension\n\nReturns:\n\nOne dimensional mesh object\n\nExample:\n\n# generate 1D mesh\nmesh = Mesh1D(1.0);\n\n# verify\nprintln(mesh)\n\n# output\n1d mesh:\n    dx: 1.0\n\n\n\n\n\n","category":"type"},{"location":"public/mesh/#LFAToolkit.Mesh2D","page":"-","title":"LFAToolkit.Mesh2D","text":"Mesh2D(dx, dy)\n\nTwo dimensional regular background mesh\n\nArguments:\n\ndx: deformation in x dimension\ndy: deformation in y dimension\n\nReturns:\n\nTwo dimensional mesh object\n\nExample:\n\n# generate 2D mesh\nmesh = Mesh2D(1.0, 0.5);\n\n# verify\nprintln(mesh)\n\n# output\n2d mesh:\n    dx: 1.0\n    dy: 0.5\n\n\n\n\n\n","category":"type"},{"location":"public/mesh/#LFAToolkit.Mesh3D","page":"-","title":"LFAToolkit.Mesh3D","text":"Mesh3D(dx, dy, dz)\n\nThree dimensional regular background mesh\n\nArguments:\n\ndx: deformation in x dimension\ndy: deformation in y dimension\ndz: deformation in z dimension\n\nReturns:\n\nThree dimensional mesh object\n\nExample:\n\n# generate 3D mesh\nmesh = Mesh3D(1.0, 0.5, 0.3);\n\n# verify\nprintln(mesh)\n\n# output\n3d mesh:\n    dx: 1.0\n    dy: 0.5\n    dz: 0.3\n\n\n\n\n\n","category":"type"},{"location":"public/pc/identity/#Preconditioner:-Identity","page":"-","title":"Preconditioner: Identity","text":"","category":"section"},{"location":"public/pc/identity/","page":"-","title":"-","text":"The identity preconditioner object allows investigation of multigrid methods without smoothers.","category":"page"},{"location":"public/pc/identity/#Documentation","page":"-","title":"Documentation","text":"","category":"section"},{"location":"public/pc/identity/","page":"-","title":"-","text":"IdentityPC\ncomputesymbols(::IdentityPC, ::Array, ::Array)","category":"page"},{"location":"public/pc/identity/#LFAToolkit.IdentityPC","page":"-","title":"LFAToolkit.IdentityPC","text":"IdentityPC()\n\nIdentity preconditioner to investigate multigrid without smoother\n\nReturns:\n\nIdentity preconditioner object\n\nExample:\n\n# preconditioner\nidentity = IdentityPC();\n\n# verify\nprintln(identity)\n\n# output\nidentity preconditioner\n\n\n\n\n\n","category":"type"},{"location":"public/pc/identity/#LFAToolkit.computesymbols-Tuple{IdentityPC, Array, Array}","page":"-","title":"LFAToolkit.computesymbols","text":"computesymbols(preconditioner, ω, θ)\n\nCompute or retrieve the symbol matrix for a Jacobi preconditioned operator\n\nArguments:\n\npreconditioner: Identity preconditioner to compute symbol matrix for\nω:              Smoothing weighting factor array\nθ:              Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the identity preconditioner (I)\n\nExample:\n\nusing LinearAlgebra\n\n# preconditioner\nidentity = IdentityPC();\n\n# compute symbols\nA = computesymbols(identity, [], []);\n\n# verify\n@assert A ≈ I\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/basis/#Finite-Element-Basis","page":"-","title":"Finite Element Basis","text":"","category":"section"},{"location":"private/basis/","page":"-","title":"-","text":"LFAToolkit.AbstractBasis\nLFAToolkit.gaussquadrature\nLFAToolkit.lobattoquadrature\nLFAToolkit.TensorMacroElementBasisFrom1D\nLFAToolkit.TensorHProlongationBasis\nLFAToolkit.buildinterpolationandgradient\nLFAToolkit.getnumbernodes\nLFAToolkit.getnodes\nLFAToolkit.getnumberquadraturepoints\nLFAToolkit.getquadraturepoints\nLFAToolkit.getquadratureweights\nLFAToolkit.getinterpolation\nLFAToolkit.getgradient\nLFAToolkit.getnumbermodes\nLFAToolkit.getmodemap\nLFAToolkit.getnumberelements\nLFAToolkit.getdiagonal\nLFAToolkit.getdXdxgradient","category":"page"},{"location":"private/basis/#LFAToolkit.AbstractBasis","page":"-","title":"LFAToolkit.AbstractBasis","text":"Finite element basis for function spaces and test spaces\n\n\n\n\n\n","category":"type"},{"location":"private/basis/#LFAToolkit.gaussquadrature","page":"-","title":"LFAToolkit.gaussquadrature","text":"gaussquadrature(q)\n\nConstruct a Gauss-Legendre quadrature\n\nArguments:\n\nq: number of Gauss-Legendre points\n\nReturns:\n\nGauss-Legendre quadrature points and weights\n\nExample:\n\n# generate Gauss-Legendre points and weights\nquadraturepoints, quadratureweights = LFAToolkit.gaussquadrature(5);\n\n# verify\ntruepoints = [\n    -√(5 + 2*√(10/7))/3,\n    -√(5 - 2*√(10/7))/3,\n    0.0,\n    √(5 - 2*√(10/7))/3,\n    √(5 + 2*√(10/7))/3\n];\n@assert truepoints ≈ quadraturepoints\n\ntrueweights = [\n    (322-13*√70)/900,\n    (322+13*√70)/900,\n    128/225,\n    (322+13*√70)/900,\n    (322-13*√70)/900\n];\n@assert trueweights ≈ quadratureweights\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.lobattoquadrature","page":"-","title":"LFAToolkit.lobattoquadrature","text":"lobattoquadrature(q, weights)\n\nConstruct a Gauss-Lobatto quadrature\n\nArguments:\n\nq:       number of Gauss-Lobatto points\nweights: boolean flag indicating if quadrature weights are desired\n\nReturns:\n\nGauss-Lobatto quadrature points or points and weights\n\nExample:\n\n# generate Gauss-Lobatto points\nquadraturepoints = LFAToolkit.lobattoquadrature(5, false);\n\n# verify\ntruepoints = [-1.0, -√(3/7), 0.0, √(3/7), 1.0];\n@assert truepoints ≈ quadraturepoints\n\n# generate Gauss-Lobatto points and weights\nquadraturepoints, quadratureweights = LFAToolkit.lobattoquadrature(5, true);\n\n# verify\ntrueweights = [1/10, 49/90, 32/45, 49/90, 1/10];\n@assert trueweights ≈ quadratureweights\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.TensorMacroElementBasisFrom1D","page":"-","title":"LFAToolkit.TensorMacroElementBasisFrom1D","text":"TensorMacroElementBasisFrom1D(\n    numbernodes1d,\n    numberquadraturepoints1d,\n    numbercomponents,\n    dimension,\n    numberelements1d,\n    basis1dmicro,\n    overlapquadraturepoints = false,\n)\n\nTensor product macro-element basis from 1d single element tensor product basis\n\nArguments:\n\nnumbernodes1d:            number of basis nodes\nnumberquadraturepoints1d: number of quadrature points\nnumbercomponents:         number of components\ndimension:                dimension of basis\nnumberelements1d:         number of elements in macro-element\nbasis1dmicro:             1d micro element basis to replicate \n\nReturns:\n\nTensor product macro-element basis object\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.TensorHProlongationBasis","page":"-","title":"LFAToolkit.TensorHProlongationBasis","text":"TensorHProlongationBasis(\n    coarsenodes1d,\n    finenodes1d,\n    numbercomponents,\n    dimension,\n    numberfineelements1d,\n)\n\nTensor product h prolongation basis\n\nArguments:\n\ncoarsenodes1d:        coarse grid node coordinates in 1d\nfinenodes1d:          fine grid node coordinates in 1d\nnumbercomponents:     number of components\ndimension:            dimension of basis\nnumberfineelements1d: number of fine grid elements\n\nReturns:\n\nH1 tensor product h prolongation basis object\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.buildinterpolationandgradient","page":"-","title":"LFAToolkit.buildinterpolationandgradient","text":"buildinterpolationandgradient(\n    nodes,\n    quadraturepoints,\n)\n\nBuild one dimensional interpolation and gradient matrices, from Fornberg 1998\n\nArguments:\n\nnodes:            1d basis nodes\nquadraturepoints: 1d basis quadrature points\n\nReturns:\n\nOne dimensional interpolation and gradient matrices\n\nExample:\n\n# get nodes, quadrature points, and weights\nnumbernodes = 3;\nnumberquadraturepoints = 4;\nnodes = LFAToolkit.lobattoquadrature(numbernodes, false);\nquadraturepoints, quadratureweights1d = LFAToolkit.gaussquadrature(numberquadraturepoints);\n\n# build interpolation, gradient matrices\ninterpolation, gradient = LFAToolkit.buildinterpolationandgradient(nodes, quadraturepoints);\n\n# verify\nfor i in 1:numberquadraturepoints\n    total = sum(interpolation[i, :]);\n    @assert total ≈ 1.0\n\n    total = sum(gradient[i, :]);\n    @assert abs(total) < 1e-14\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getnumbernodes","page":"-","title":"LFAToolkit.getnumbernodes","text":"getnumbernodes(basis)\n\nGet the number of nodes for the basis\n\nArguments:\n\nbasis: basis to compute number of nodes\n\nReturns:\n\nInteger number of basis nodes\n\nExample:\n\n# get number of nodes for basis\nbasis = TensorH1LagrangeBasis(4, 3, 2, 2);\n\n# note: either syntax works\nnumbernodes = LFAToolkit.getnumbernodes(basis);\nnumbernodes = basis.numbernodes;\n\n# verify\n@assert numbernodes == 4^2\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getnodes","page":"-","title":"LFAToolkit.getnodes","text":"getnodes(basis)\n\nGet nodes for basis\n\nReturns:\n\nBasis nodes array\n\nArguments:\n\nbasis: basis to compute nodes\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get basis quadrature weights\n    basis = TensorH1LagrangeBasis(4, 3, 2, dimension);\n\n    # note: either syntax works\n    nodes = LFAToolkit.getnodes(basis);\n    nodes = basis.nodes;\n\n    # verify\n    truenodes1d = [-1, -√(1/5), √(1/5), 1];\n    truenodes = [];\n    if dimension == 1\n        truenodes = truenodes1d;\n    elseif dimension == 2\n        truenodes =\n            transpose(hcat([[[x, y] for x in truenodes1d, y in truenodes1d]...]...));\n    elseif dimension == 3\n        truenodes = transpose(hcat([[\n            [x, y, z] for x in truenodes1d, y in truenodes1d, z in truenodes1d\n        ]...]...));\n    end\n\n    @assert truenodes ≈ nodes\nend\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getnumberquadraturepoints","page":"-","title":"LFAToolkit.getnumberquadraturepoints","text":"getnumberquadraturepoints(basis)\n\nGet the number of quadrature points for the basis\n\nArguments:\n\nbasis: basis to compute number of quadrature points\n\nReturns:\n\nInteger number of basis quadrature points\n\nExample:\n\n# get number of quadrature points for basis\nbasis = TensorH1LagrangeBasis(4, 3, 2, 2);\n\n# note: either syntax works\nnumberquadraturepoints = LFAToolkit.getnumberquadraturepoints(basis);\nnumberquadraturepoints = basis.numberquadraturepoints;\n    \n# verify\n@assert numberquadraturepoints == 3^2\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getquadraturepoints","page":"-","title":"LFAToolkit.getquadraturepoints","text":"getquadraturepoints(basis)\n\nGet quadrature points for basis\n\nReturns:\n\nBasis quadrature points array\n\nArguments:\n\nbasis: basis to compute quadrature points\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get basis quadrature weights\n    basis = TensorH1LagrangeBasis(4, 3, 2, dimension);\n\n    # note: either syntax works\n    quadraturepoints = LFAToolkit.getquadraturepoints(basis);\n    quadraturepoints = basis.quadraturepoints;\n\n    # verify\n    truequadraturepoints1d = [-√(3/5), 0, √(3/5)];\n    truequadraturepoints = [];\n    if dimension == 1\n        truequadraturepoints = truequadraturepoints1d;\n    elseif dimension == 2\n        truequadraturepoints = transpose(hcat([[\n            [x, y] for x in truequadraturepoints1d, y in truequadraturepoints1d\n        ]...]...));\n    elseif dimension == 3\n        truequadraturepoints = transpose(hcat([[\n            [x, y, z]\n            for\n            x in truequadraturepoints1d,\n            y in truequadraturepoints1d, z in truequadraturepoints1d\n        ]...]...));\n    end\n\n    @assert truequadraturepoints ≈ quadraturepoints\nend\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getquadratureweights","page":"-","title":"LFAToolkit.getquadratureweights","text":"getquadratureweights(basis)\n\nGet full quadrature weights vector for basis\n\nReturns:\n\nBasis quadrature weights vector\n\nArguments:\n\nbasis: basis to compute quadrature weights\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get basis quadrature weights\n    basis = TensorH1LagrangeBasis(4, 3, 2, dimension);\n\n    # note: either syntax works\n    quadratureweights = LFAToolkit.getquadratureweights(basis);\n    quadratureweights = basis.quadratureweights;\n\n    # verify\n    trueweights1d = [5/9, 8/9, 5/9];\n    trueweights = [];\n    if dimension == 1\n        trueweights = trueweights1d;\n    elseif dimension == 2\n        trueweights = kron(trueweights1d, trueweights1d);\n    elseif dimension == 3\n        trueweights = kron(trueweights1d, trueweights1d, trueweights1d);\n    end\n\n    @assert trueweights ≈ quadratureweights\nend\n    \n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getinterpolation","page":"-","title":"LFAToolkit.getinterpolation","text":"getinterpolation(basis)\n\nGet full interpolation matrix for basis\n\nArguments:\n\nbasis: basis to compute interpolation matrix\n\nReturns:\n\nBasis interpolation matrix\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get basis interpolation matrix\n    basis = TensorH1LagrangeBasis(4, 3, 2, dimension);\n\n    # note: either syntax works\n    interpolation = LFAToolkit.getinterpolation(basis);\n    interpolation = basis.interpolation;\n\n    # verify\n    for i in 1:3^dimension\n        total = sum(interpolation[i, :]);\n        @assert total ≈ 1.0\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getgradient","page":"-","title":"LFAToolkit.getgradient","text":"getgradient(basis)\n\nGet full gradient matrix for basis\n\nArguments:\n\nbasis: basis to compute gradient matrix\n\nReturns:\n\nBasis gradient matrix\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get basis gradient matrix\n    basis = TensorH1LagrangeBasis(4, 3, 2, dimension);\n\n    # note: either syntax works\n    gradient = LFAToolkit.getgradient(basis);\n    gradient = basis.gradient;\n\n    # verify\n    for i in 1:dimension*3^dimension\n        total = sum(gradient[i, :]);\n        @assert abs(total) < 1e-14\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getnumbermodes","page":"-","title":"LFAToolkit.getnumbermodes","text":"getnumbermodes(basis)\n\nGet number of modes for basis\n\nArguments:\n\nbasis: basis to compute number of modes\n\nReturns:\n\nNumber of modes for basis\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get number of basis modes\n    basis = TensorH1LagrangeBasis(4, 3, 2, dimension);\n\n    # note: either syntax works\n    numbermodes = LFAToolkit.getnumbermodes(basis);\n    numbermodes = basis.numbermodes;\n\n    # verify\n    @assert numbermodes == 2*3^dimension\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getmodemap","page":"-","title":"LFAToolkit.getmodemap","text":"getmodemap(basis)\n\nGet mode mapping vector for basis\n\nArguments:\n\nbasis: basis to compute mode map vector\n\nReturns:\n\nBasis mode map vector\n\nExample:\n\n# test for all supported dimensions\nfor dimension in 1:3\n    # get mode map vector\n    basis = TensorH1LagrangeBasis(4, 3, 1, dimension);\n\n    # note: either syntax works\n    modemap = LFAToolkit.getmodemap(basis);\n    modemap = basis.modemap;\n\n    # verify\n    truemodemap1d = [1, 2, 3, 1];\n    truemodemap = [];\n    if dimension == 1\n        truemodemap = truemodemap1d;\n    elseif dimension == 2\n        truemodemap = [[\n            i + (j - 1)*3 for i in truemodemap1d, j in truemodemap1d\n        ]...];\n    elseif dimension == 3\n        truemodemap = [[\n            i +\n            (j - 1)*3 +\n            (k - 1)*3^2\n            for i in truemodemap1d, j in truemodemap1d, k in truemodemap1d\n        ]...];\n    end\n\n    @assert truemodemap == modemap\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getnumberelements","page":"-","title":"LFAToolkit.getnumberelements","text":"getnumberelements(basis)\n\nGet the number of elements for the basis\n\nArguments:\n\nbasis: basis to compute number of micro-elements\n\nReturns:\n\nInteger number of basis micro-elements\n\nExample:\n\n# get number of nodes for basis\nbasis = TensorH1LagrangeMacroBasis(4, 4, 1, 2, 2);\n\n# note: either syntax works\nnumbernodes = LFAToolkit.getnumberelements(basis);\nnumbernodes = basis.numberelements;\n\n# verify\n@assert numbernodes == 2^2\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getdiagonal","page":"-","title":"LFAToolkit.getdiagonal","text":"getdiagonal(operator)\n\nCompute or retrieve the symbol matrix diagonal for an operator\n\nReturns:\n\nSymbol matrix diagonal for the operator\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n# note: either syntax works\ndiagonal = LFAToolkit.getdiagonal(diffusion);\ndiagonal = diffusion.diagonal;\n\n# verify\n@assert diagonal ≈ [14/3 0; 0 16/3]\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/basis/#LFAToolkit.getdXdxgradient","page":"-","title":"LFAToolkit.getdXdxgradient","text":"getdXdxgradient(basis, mesh)\n\nGet gradient adjusted for mesh stretching\n\nArguments:\n\nbasis: basis to compute gradient\nmesh:  mesh to compute gradient\n\nReturns:\n\ngradient matrix multiplied by change of coordinates adjoint\n\nExample:\n\nfor dimension in 1:3\n    # mesh\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(2.0)\n    elseif dimension == 2\n        mesh = Mesh2D(2.0, 3.0)\n    elseif dimension == 3\n        mesh = Mesh3D(2.0, 3.0, 4.0)\n    end\n\n    # basis\n    basis = TensorH1LagrangeBasis(4, 3, 1, dimension);\n\n    # get gradient on mesh\n    gradient = LFAToolkit.getdXdxgradient(basis, mesh);\n\n    # verify\n    nodes = basis.nodes;\n    linearfunction = [];\n    truegradient = [];\n    if dimension == 1\n        linearfunction = nodes/2;\n        truegradient = [1/2*ones(basis.numberquadraturepoints)...]\n    elseif dimension == 2\n        linearfunction = (nodes[:, 1] + nodes[:, 2])/2;\n        truegradient = [\n            1/2*ones(basis.numberquadraturepoints)...\n            1/3*ones(basis.numberquadraturepoints)...\n        ]\n    elseif dimension == 3\n        linearfunction = (nodes[:, 1] + nodes[:, 2] + nodes[:, 3])/2;\n        truegradient = [\n            1/2*ones(basis.numberquadraturepoints)...\n            1/3*ones(basis.numberquadraturepoints)...\n            1/4*ones(basis.numberquadraturepoints)...\n        ]\n    end\n\n    @assert gradient*linearfunction ≈ truegradient\nend\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"public/pc/multigrid/#Preconditioner:-Multigrid","page":"-","title":"Preconditioner: Multigrid","text":"","category":"section"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"LFAToolkit supports both p-multigrid and h-multigrid.","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"MultigridType.MgridType","category":"page"},{"location":"public/pc/multigrid/#LFAToolkit.MultigridType.MgridType","page":"-","title":"LFAToolkit.MultigridType.MgridType","text":"Multigrid types\n\nModes:\n\npmultigrid: p-multigrid\nhmultigrid: h-multigrid\n\nExample:\n\nLFAToolkit.MultigridType.MgridType\n\n# output\nEnum LFAToolkit.MultigridType.MgridType:\npmultigrid = 0\nhmultigrid = 1\n\n\n\n\n\n","category":"type"},{"location":"public/pc/multigrid/#P-Multigrid","page":"-","title":"P-Multigrid","text":"","category":"section"},{"location":"public/pc/multigrid/#Example","page":"-","title":"Example","text":"","category":"section"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"This is an example of a simple p-multigrid preconditioner.","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex201_pmultigrid.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"Example plot for the symbol of p-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"This is an example of a multilevel p-multigrid preconditioner.","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex202_pmultigrid_multilevel.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"Example plot for the symbol of multilevel p-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"public/pc/multigrid/#Documentation","page":"-","title":"Documentation","text":"","category":"section"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"PMultigrid\ncomputesymbols(::Multigrid, ::Array, ::Array{Int}, ::Array)","category":"page"},{"location":"public/pc/multigrid/#LFAToolkit.PMultigrid","page":"-","title":"LFAToolkit.PMultigrid","text":"Pmultigrid(fineoperator, coarseoperator, smoother, prolongation)\n\nP-Multigrid preconditioner for finite element operators\n\nArguments:\n\nfineoperator:      finite element operator to precondition\ncoarseoperator:    coarse grid representation of finite element operator to                          precondition\nsmoother:          error relaxation operator, such as Jacobi\nprolongationbases: element prolongation bases from coarse to fine grid\n\nReturns:\n\nP-multigrid preconditioner object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nctofbasis = TensorH1LagrangePProlongationBasis(3, 5, 1, 2);\n\n# operators\nfinediffusion = GalleryOperator(\"diffusion\", 5, 5, mesh);\ncoarsediffusion = GalleryOperator(\"diffusion\", 3, 5, mesh);\n\n# smoother\njacobi = Jacobi(finediffusion);\n\n# preconditioner\nmultigrid = PMultigrid(finediffusion, coarsediffusion, jacobi, [ctofbasis]);\n\n# verify\nprintln(multigrid)\nprintln(multigrid.fineoperator)\n\n# output\np-multigrid preconditioner\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 5\n    numberquadraturepoints1d: 5\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\noperator field:\n  tensor product basis:\n    numbernodes1d: 5\n    numberquadraturepoints1d: 5\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 5\n    numberquadraturepoints1d: 5\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"public/pc/multigrid/#LFAToolkit.computesymbols-Tuple{Multigrid, Array, Array{Int64, N} where N, Array}","page":"-","title":"LFAToolkit.computesymbols","text":"computesymbols(multigrid, p, v, θ)\n\nCompute or retrieve the symbol matrix for a Jacobi preconditioned operator\n\nArguments:\n\nmultigrid: Multigrid preconditioner to compute symbol matrix for\np:         Smoothing paramater array\nv:         Pre and post smooths iteration count array, 0 indicates no pre or post smoothing\nθ:         Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the multigrid preconditioned operator\n\nExample:\n\nusing LinearAlgebra\n\nfor dimension in 1:3\n    # setup\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(1.0);\n    elseif dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    ctofbasis = TensorH1LagrangeBasis(3, 5, 1, dimension, lagrangequadrature=true);\n\n    # operators\n    finediffusion = GalleryOperator(\"diffusion\", 5, 5, mesh);\n    coarsediffusion = GalleryOperator(\"diffusion\", 3, 5, mesh);\n\n    # smoother\n    jacobi = Jacobi(finediffusion);\n\n    # preconditioner\n    multigrid = PMultigrid(finediffusion, coarsediffusion, jacobi, [ctofbasis]);\n\n    # compute symbols\n    A = computesymbols(multigrid, [1.0], [1, 1], π*ones(dimension));\n\n    # verify\n    eigenvalues = real(eigvals(A));\n    if dimension == 1\n       @assert max(eigenvalues...) ≈ 0.64\n    elseif dimension == 2\n       @assert max(eigenvalues...) ≈ 0.9082562365654528\n    elseif dimension == 3\n       @assert max(eigenvalues...) ≈ 1.4359882222222669\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"public/pc/multigrid/#H-Multigrid","page":"-","title":"H-Multigrid","text":"","category":"section"},{"location":"public/pc/multigrid/#Example-2","page":"-","title":"Example","text":"","category":"section"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"This is an example of a simple h-multigrid preconditioner.","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex211_hmultigrid.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"Example plot for the symbol of h-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with linear basis.","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"This is an example of a multilevel h-multigrid preconditioner.","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"using Markdown \nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex212_hmultigrid_multilevel.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"Example plot for the symbol of multilevel h-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with linear basis.","category":"page"},{"location":"public/pc/multigrid/#Documentation-2","page":"-","title":"Documentation","text":"","category":"section"},{"location":"public/pc/multigrid/","page":"-","title":"-","text":"HMultigrid","category":"page"},{"location":"public/pc/multigrid/#LFAToolkit.HMultigrid","page":"-","title":"LFAToolkit.HMultigrid","text":"Hmultigrid(fineoperator, coarseoperator, smoother, prolongation)\n\nH-Multigrid preconditioner for finite element operators\n\nArguments:\n\nfineoperator:      finite element operator to precondition\ncoarseoperator:    coarse grid representation of finite element operator to                          precondition\nsmoother:          error relaxation operator, such as Jacobi\nprolongationbases: element prolongation bases from coarse to fine grid\n\nReturns:\n\nH-multigrid preconditioner object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nctofbasis = TensorH1LagrangeHProlongationBasis(2, 1, 2, 2);\n\n# operators\nfunction diffusionweakform(du::Array{Float64}, w::Array{Float64})\n    dv = du*w[1]\n    return [dv]\nend\n# -- fine\nbasis = TensorH1LagrangeMacroBasis(2, 3, 1, 2, 2);\ninputs = [\n    OperatorField(basis, [EvaluationMode.gradient]),\n    OperatorField(basis, [EvaluationMode.quadratureweights]),\n];\noutputs = [OperatorField(basis, [EvaluationMode.gradient])];\nfinediffusion = Operator(diffusionweakform, mesh, inputs, outputs);\n# -- fine\nbasis = TensorH1LagrangeBasis(2, 3, 1, 2);\ninputs = [\n    OperatorField(basis, [EvaluationMode.gradient]),\n    OperatorField(basis, [EvaluationMode.quadratureweights]),\n];\noutputs = [OperatorField(basis, [EvaluationMode.gradient])];\ncoarsediffusion = Operator(diffusionweakform, mesh, inputs, outputs);\n\n# smoother\njacobi = Jacobi(finediffusion);\n\n# preconditioner\nmultigrid = HMultigrid(finediffusion, coarsediffusion, jacobi, [ctofbasis]);\n\n# verify\nprintln(multigrid)\nprintln(multigrid.fineoperator)\n\n# output\nh-multigrid preconditioner\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  macro-element tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 6\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n  evaluation mode:\n    gradient\noperator field:\n  macro-element tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 6\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  macro-element tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 6\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"private/#Private-API","page":"Private API","title":"Private API","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"This section documents the private API of the LFAToolkit.","category":"page"},{"location":"private/#Contents","page":"Private API","title":"Contents","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"Pages = [\n    \"private/mesh.md\",\n    \"private/basis.md\",\n    \"private/operator.md\",\n    \"private/pc/base.md\",\n    \"private/pc/jacobi.md\",\n    \"private/pc/chebyshev.md\",\n    \"private/pc/multigrid.md\",\n]","category":"page"},{"location":"public/pc/chebyshev/#Preconditioner:-Chebyshev","page":"-","title":"Preconditioner: Chebyshev","text":"","category":"section"},{"location":"public/pc/chebyshev/","page":"-","title":"-","text":"This smoother provides Chekyshev polynomial smoothing of a runtime specified order.","category":"page"},{"location":"public/pc/chebyshev/#Example","page":"-","title":"Example","text":"","category":"section"},{"location":"public/pc/chebyshev/","page":"-","title":"-","text":"This is an example of a Chebyshev smoother.","category":"page"},{"location":"public/pc/chebyshev/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex111_chebyshev.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/chebyshev/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/chebyshev/","page":"-","title":"-","text":"Plot for the symbol a cubic Chebyshev smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"public/pc/chebyshev/#Documentation","page":"-","title":"Documentation","text":"","category":"section"},{"location":"public/pc/chebyshev/","page":"-","title":"-","text":"Chebyshev\nseteigenvalueestimatescaling\ncomputesymbols(::Chebyshev, ::Array, ::Array)","category":"page"},{"location":"public/pc/chebyshev/#LFAToolkit.Chebyshev","page":"-","title":"LFAToolkit.Chebyshev","text":"Chebyshev(operator)\n\nChebyshev polynomial preconditioner for finite element operators.     The Chebyshev semi-iterative method is applied to the matrix D^-1 A,     where D^-1 is the inverse of the operator diagonal.\n\nArguments:\n\noperator: finite element operator to precondition\n\nReturns:\n\nChebyshev preconditioner object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# preconditioner\nchebyshev = Chebyshev(mass);\n\n# verify\nprintln(chebyshev)\n\n# output\nchebyshev preconditioner:\neigenvalue estimates:\n  estimated minimum 0.6944\n  estimated maximum 1.3611\nestimate scaling:\n  λ_min = a * estimated min + b * estimated max\n  λ_max = c * estimated min + d * estimated max\n  a = 1.0000\n  b = 0.0000\n  c = 0.0000\n  d = 1.0000\n\n\n\n\n\n","category":"type"},{"location":"public/pc/chebyshev/#LFAToolkit.seteigenvalueestimatescaling","page":"-","title":"LFAToolkit.seteigenvalueestimatescaling","text":"seteigenvalueestimatescaling(preconditioner, eigenvaluebounds)\n\nSet the scaling of the eigenvalue estimates for a Chebyshev preconditioner\n\nArguments:\n\neigenvaluebounds: array of 4 scaling factors to use when setting lambda_textmin   and lambda_textmax based on eigenvalue estimates\n\nlambda_textmin = a * estimated min + b * estimated max\n\nlambda_textmax = c * estimated min + d * estimated max\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n# preconditioner\nchebyshev = Chebyshev(diffusion)\n\n# set eigenvalue estimate scaling\n# PETSc default is to use 1.1, 0.1 of max eigenvalue estimate\n#   https://www.mcs.anl.gov/petsc/petsc-3.3/docs/manualpages/KSP/KSPChebyshevSetEstimateEigenvalues.html\nseteigenvalueestimatescaling(chebyshev, [0.0, 0.1, 0.0, 1.1]);\nprintln(chebyshev)\n \n# output\nchebyshev preconditioner:\neigenvalue estimates:\n  estimated minimum 0.0000\n  estimated maximum 2.1429\nestimate scaling:\n  λ_min = a * estimated min + b * estimated max\n  λ_max = c * estimated min + d * estimated max\n  a = 0.0000\n  b = 0.1000\n  c = 0.0000\n  d = 1.1000\n\n\n\n\n\n","category":"function"},{"location":"public/pc/chebyshev/#LFAToolkit.computesymbols-Tuple{Chebyshev, Array, Array}","page":"-","title":"LFAToolkit.computesymbols","text":"computesymbols(preconditioner, ω, θ)\n\nCompute or retrieve the symbol matrix for a Chebyshev preconditioned operator\n\nArguments:\n\npreconditioner: Chebyshev preconditioner to compute symbol matrix for\nω:              Smoothing parameter array                     [degree], [degree, lambda_textmax], or                     [degree, lambda_textmin, lambda_textmax]\nθ:              Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the Chebyshev preconditioned operator\n\nExample:\n\nusing LinearAlgebra\n\nfor dimension in 1:3\n    # setup\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(1.0);\n    elseif dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    diffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n    # preconditioner\n    chebyshev = Chebyshev(diffusion);\n\n    # compute symbols\n    A = computesymbols(chebyshev, [1], π*ones(dimension));\n\n    # verify\n    using LinearAlgebra;\n    eigenvalues = real(eigvals(A));\n    minmax = [min(eigenvalues...), max(eigenvalues...)]\n    if dimension == 1\n        @assert minmax ≈ [\n            -0.07142857142857095,\n            0.0816326530612248,\n        ]\n    elseif dimension == 2\n        @assert minmax ≈ [\n            0.16841432714259774,\n            0.22385337199975813,\n        ]\n    elseif dimension == 3\n        @assert minmax ≈ [\n            0.10734492838301535,\n            0.333484213192652,\n        ]\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/pc/multigrid/#Preconditioner:-Multigrid","page":"-","title":"Preconditioner: Multigrid","text":"","category":"section"},{"location":"private/pc/multigrid/","page":"-","title":"-","text":"Multigrid\nLFAToolkit.getnodecoordinatedifferences(::Multigrid)\nLFAToolkit.getprolongationmatrix\nLFAToolkit.computesymbolsprolongation\nLFAToolkit.computesymbolsrestriction","category":"page"},{"location":"private/pc/multigrid/#LFAToolkit.Multigrid","page":"-","title":"LFAToolkit.Multigrid","text":"multigrid(fineoperator, coarseoperator, smoother, prolongation)\n\nMultigrid preconditioner for finite element operators\n\nArguments:\n\nfineoperator:      finite element operator to precondition\ncoarseoperator:    coarse grid representation of finite element operator to                          precondition\nsmoother:          error relaxation operator, such as Jacobi\nprolongationbases: element prolongation bases from coarse to fine grid\n\nReturns:\n\nMultigrid preconditioner object\n\n\n\n\n\n","category":"type"},{"location":"private/pc/multigrid/#LFAToolkit.getnodecoordinatedifferences-Tuple{Multigrid}","page":"-","title":"LFAToolkit.getnodecoordinatedifferences","text":"getnodecoordinateddifferences(multigrid)\n\nCompute or retrieve the array of differences in coordinates between nodes\n\nReturns:\n\nArray of differences in coordinates between nodes\n\n\n\n\n\n","category":"method"},{"location":"private/pc/multigrid/#LFAToolkit.getprolongationmatrix","page":"-","title":"LFAToolkit.getprolongationmatrix","text":"getprolongationmatrix(multigrid)\n\nCompute or retrieve the prolongation matrix\n\nReturns:\n\nMatrix prolonging from coarse grid to fine grid\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nctofbasis = TensorH1LagrangeBasis(2, 3, 1, 2, lagrangequadrature=true);\n\n# operators\nfinediffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\ncoarsediffusion = GalleryOperator(\"diffusion\", 2, 3, mesh);\n\n# smoother\njacobi = Jacobi(finediffusion);\n\n# preconditioner\nmultigrid = PMultigrid(finediffusion, coarsediffusion, jacobi, [ctofbasis]);\n\n# verify\nu = ones(ctofbasis.numbernodes);\nv = multigrid.prolongationmatrix * u;\n@assert v' ≈ [4. 2. 4. 2. 1. 2. 4. 2. 4.].^-1\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/pc/multigrid/#LFAToolkit.computesymbolsprolongation","page":"-","title":"LFAToolkit.computesymbolsprolongation","text":"computesymbolsprolongation(multigrid, θ)\n\nCompute the symbol matrix for a multigrid prolongation operator\n\nArguments:\n\nmultigrid: Multigrid operator to compute prolongation symbol matrix for\nθ:         Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the multigrid prolongation operator\n\n\n\n\n\n","category":"function"},{"location":"private/pc/multigrid/#LFAToolkit.computesymbolsrestriction","page":"-","title":"LFAToolkit.computesymbolsrestriction","text":"computesymbolsrestriction(multigrid, θ)\n\nCompute the symbol matrix for a multigrid restriction operator\n\nArguments:\n\nmultigrid: Multigrid operator to compute restriction symbol matrix for\nθ:         Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the multigrid restriction operator\n\n\n\n\n\n","category":"function"},{"location":"public/pc/jacobi/#Preconditioner:-Jacobi","page":"-","title":"Preconditioner: Jacobi","text":"","category":"section"},{"location":"public/pc/jacobi/","page":"-","title":"-","text":"This smoother provides Jacobi smoothing based on the operator diagonal.","category":"page"},{"location":"public/pc/jacobi/#Example","page":"-","title":"Example","text":"","category":"section"},{"location":"public/pc/jacobi/","page":"-","title":"-","text":"This is an example of a simple Jacobi smoother.","category":"page"},{"location":"public/pc/jacobi/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../../examples/ex101_jacobi.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/pc/jacobi/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/pc/jacobi/","page":"-","title":"-","text":"Plot for the symbol of a Jacobi smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"public/pc/jacobi/#Documentation","page":"-","title":"Documentation","text":"","category":"section"},{"location":"public/pc/jacobi/","page":"-","title":"-","text":"Jacobi\ncomputesymbols(::Jacobi, ::Array, ::Array)","category":"page"},{"location":"public/pc/jacobi/#LFAToolkit.Jacobi","page":"-","title":"LFAToolkit.Jacobi","text":"Jacobi(operator)\n\nJacobi diagonal preconditioner for finite element operators\n\nArguments:\n\noperator: finite element operator to precondition\n\nReturns:\n\nJacobi preconditioner object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# preconditioner\njacobi = Jacobi(mass);\n\n# verify\nprintln(jacobi)\nprintln(jacobi.operator)\n\n# output\njacobi preconditioner\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\n\n\n\n\n\n","category":"type"},{"location":"public/pc/jacobi/#LFAToolkit.computesymbols-Tuple{Jacobi, Array, Array}","page":"-","title":"LFAToolkit.computesymbols","text":"computesymbols(preconditioner, ω, θ)\n\nCompute or retrieve the symbol matrix for a Jacobi preconditioned operator\n\nArguments:\n\npreconditioner: Jacobi preconditioner to compute symbol matrix for\nω:              Smoothing weighting factor array\nθ:              Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the Jacobi preconditioned operator\n\nExample:\n\nusing LinearAlgebra\n\nfor dimension in 1:3\n    # setup\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(1.0);\n    elseif dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    diffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n    # preconditioner\n    jacobi = Jacobi(diffusion);\n\n    # compute symbols\n    A = computesymbols(jacobi, [1.0], π*ones(dimension));\n\n    # verify\n    using LinearAlgebra;\n    eigenvalues = real(eigvals(A));\n    if dimension == 1\n        @assert max(eigenvalues...) ≈ 1/7\n    elseif dimension == 2\n        @assert min(eigenvalues...) ≈ -1/14\n    elseif dimension == 3\n        @assert min(eigenvalues...) ≈ -0.33928571428571486\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"examples/solidmechanics/#Neo-Hookean-hyperelasticity","page":"-","title":"Neo-Hookean hyperelasticity","text":"","category":"section"},{"location":"examples/solidmechanics/","page":"-","title":"-","text":"This is an example of a p-multigrid preconditioner with Chebyshev smoothing for the 3D Neo-Hookean hyperelasticity problem.","category":"page"},{"location":"examples/solidmechanics/#Problem-formulation","page":"-","title":"Problem formulation","text":"","category":"section"},{"location":"examples/solidmechanics/","page":"-","title":"-","text":"The strong form of the static balance of linear-momentum at finite strain is given by","category":"page"},{"location":"examples/solidmechanics/","page":"-","title":"-","text":"-nabla_x cdot boldP - rho_0 boldg = bold0","category":"page"},{"location":"examples/solidmechanics/","page":"-","title":"-","text":"where -nabla_k is the gradient with respect to the reference configuration, boldP is the first Piola-Kirchhoff stress tensor, rho_0 is the reference mass density, and boldg is the forcing function.","category":"page"},{"location":"examples/solidmechanics/","page":"-","title":"-","text":"The first Piola-Kirchhoff stress tensor is given by","category":"page"},{"location":"examples/solidmechanics/","page":"-","title":"-","text":"boldP = boldF boldS","category":"page"},{"location":"examples/solidmechanics/","page":"-","title":"-","text":"where boldF is the deformation gradient and boldS is the second Piola-Kirchhoff stress tensor. In this example, the second Piola-Kirchhoff stress tensor is given by the Neo-Hookean model.","category":"page"},{"location":"examples/solidmechanics/","page":"-","title":"-","text":"For a full discussion of the formulation of the 3D Neo-Hookean hyperelasticity problem, see the libCEED documentation.","category":"page"},{"location":"examples/solidmechanics/#LFAToolkit-code","page":"-","title":"LFAToolkit code","text":"","category":"section"},{"location":"examples/solidmechanics/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex301_solidmechanics.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"private/pc/base/#Preconditioner:-Abstract-Base-Class","page":"-","title":"Preconditioner: Abstract Base Class","text":"","category":"section"},{"location":"private/pc/base/","page":"-","title":"-","text":"LFAToolkit.AbstractPreconditioner","category":"page"},{"location":"private/pc/base/#LFAToolkit.AbstractPreconditioner","page":"-","title":"LFAToolkit.AbstractPreconditioner","text":"Finite element operator preconditioner \n\n\n\n\n\n","category":"type"},{"location":"private/operator/#Finite-Element-Operator","page":"-","title":"Finite Element Operator","text":"","category":"section"},{"location":"private/operator/","page":"-","title":"-","text":"LFAToolkit.getelementmatrix\nLFAToolkit.getmultiplicity\nLFAToolkit.getrowmodemap\nLFAToolkit.getcolumnmodemap\nLFAToolkit.getinputcoordinates\nLFAToolkit.getoutputcoordinates\nLFAToolkit.getnodecoordinatedifferences(::Operator)","category":"page"},{"location":"private/operator/#LFAToolkit.getelementmatrix","page":"-","title":"LFAToolkit.getelementmatrix","text":"getelementmatrix(operator)\n\nCompute or retrieve the element matrix of operator for computing the symbol\n\nArguments:\n\noperator: operator to compute element element matrix\n\nReturns:\n\nAssembled element matrix\n\nMass matrix example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# element matrix computation\n# note: either syntax works\nelementmatrix = LFAToolkit.getelementmatrix(mass);\nelementmatrix = mass.elementmatrix;\n\n# verify\nu = ones(4*4);\nv = elementmatrix*u;\n\ntotal = sum(v);\n@assert total ≈ 1.0\n\n# output\n\n\nDiffusion matrix example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\ndiffusion = GalleryOperator(\"diffusion\", 4, 4, mesh);\n\n# element matrix computation\n# note: either syntax works\nelementmatrix = LFAToolkit.getelementmatrix(diffusion);\nelementmatrix = diffusion.elementmatrix;\n\n# verify\nu = ones(4*4);\nv = elementmatrix*u;\n\ntotal = sum(v);\n@assert abs(total) < 1e-14\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getmultiplicity","page":"-","title":"LFAToolkit.getmultiplicity","text":"getmultiplicity(operator)\n\nCompute or retrieve the vector of node multiplicity for the operator\n\nReturns:\n\nVector of node multiplicity for the operator\n\nExample\n\n```jldoctest for dimension in 1:3     # setup     mesh = []     if dimension == 1         mesh = Mesh1D(1.0);     elseif dimension == 2         mesh = Mesh2D(1.0, 1.0);     elseif dimension == 3         mesh = Mesh3D(1.0, 1.0, 1.0);     end     diffusion = GalleryOperator(\"diffusion\", 5, 5, mesh);\n\n# compute multiplicity\nmult = diffusion.multiplicity;\n\n# verify\nmult1D = [2. 1. 1. 1. 2.];\nif dimension == 1\n    @assert mult ≈ mult1D\nelseif dimension == 2\n    @assert mult ≈ kron(mult1D, mult1D)\nelseif dimension == 3\n    @assert mult ≈ kron(mult1D, mult1D, mult1D)\nend\n\nend\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getrowmodemap","page":"-","title":"LFAToolkit.getrowmodemap","text":"getrowmodemap(operator)\n\nCompute or retrieve the matrix mapping the rows of the element matrix to the symbol matrix\n\nReturns:\n\nMatrix mapping rows of element matrix to symbol matrix\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# note: either syntax works\nmodemap = LFAToolkit.getrowmodemap(mass);\nmodemap = mass.rowmodemap;\n\n# verify\n@assert modemap ≈ [1 0 0 1; 0 1 0 0; 0 0 1 0]\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getcolumnmodemap","page":"-","title":"LFAToolkit.getcolumnmodemap","text":"getcolumnmodemap(operator)\n\nCompute or retrieve the matrix mapping the columns of the element matrix to the   symbol matrix\n\nReturns:\n\nMatrix mapping columns of element matrix to symbol matrix\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# note: either syntax works\nmodemap = LFAToolkit.getcolumnmodemap(mass);\nmodemap = mass.columnmodemap;\n\n# verify\n@assert modemap ≈ [1 0 0; 0 1 0; 0 0 1; 1 0 0]\n\n# output\n\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getinputcoordinates","page":"-","title":"LFAToolkit.getinputcoordinates","text":"getinputcoordinates(operator)\n\nCompute or retrieve the array of input coordinates\n\nReturns:\n\nArray of input coordinates\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getoutputcoordinates","page":"-","title":"LFAToolkit.getoutputcoordinates","text":"getoutputcoordinates(operator)\n\nCompute or retrieve the array of output coordinates\n\nReturns:\n\nArray of output coordinates\n\n\n\n\n\n","category":"function"},{"location":"private/operator/#LFAToolkit.getnodecoordinatedifferences-Tuple{Operator}","page":"-","title":"LFAToolkit.getnodecoordinatedifferences","text":"getnodecoordinatedifferences(operator)\n\nCompute or retrieve the array of differences in coordinates between nodes\n\nReturns:\n\nArray of differences in coordinates between nodes\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# note: either syntax works\nnodedifferences = LFAToolkit.getnodecoordinatedifferences(mass);\nnodedifferences = mass.nodecoordinatedifferences;\n\n# verify\ntruenodes = LFAToolkit.lobattoquadrature(4, false);\ntruenodedifferences = [\n    (truenodes[j] - truenodes[i])/2.0 for i in 1:4, j in 1:4\n];\n@assert nodedifferences ≈ truenodedifferences\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"private/pc/jacobi/#Preconditioner:-Jacobi","page":"-","title":"Preconditioner: Jacobi","text":"","category":"section"},{"location":"private/pc/jacobi/","page":"-","title":"-","text":"LFAToolkit.getoperatordiagonalinverse(::Jacobi)","category":"page"},{"location":"private/pc/jacobi/#LFAToolkit.getoperatordiagonalinverse-Tuple{Jacobi}","page":"-","title":"LFAToolkit.getoperatordiagonalinverse","text":"getoperatordiagonalinverse(preconditioner)\n\nCompute or retrieve the inverse of the symbol matrix diagonal for a Jacobi     preconditioner\n\nReturns:\n\nSymbol matrix diagonal inverse for the operator\n\nExample:\n\n# setup\nmesh = Mesh1D(1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n# preconditioner\njacobi = Jacobi(diffusion)\n\n# note: either syntax works\ndiagonalinverse = LFAToolkit.getoperatordiagonalinverse(jacobi);\ndiagonalinverse = jacobi.operatordiagonalinverse;\n\n# verify\n@assert diagonalinverse ≈ [3/14 0; 0 3/16]\n \n# output\n\n\n\n\n\n\n","category":"method"},{"location":"public/basis/#Finite-Element-Basis","page":"-","title":"Finite Element Basis","text":"","category":"section"},{"location":"public/basis/","page":"-","title":"-","text":"The finite element basis objects represent the discretization of the problem.","category":"page"},{"location":"public/basis/","page":"-","title":"-","text":"There are convenience constructors for H1 tensor product bases on uniformly spaced, Gauss-Lobatto, or Gauss-Legendre points with Gauss-Lobatto or Gauss-Legendre quadrature. Users can create additional finite element bases if the prerequisite information is provided.","category":"page"},{"location":"public/basis/#Base-Classes","page":"-","title":"Base Classes","text":"","category":"section"},{"location":"public/basis/","page":"-","title":"-","text":"These are the bases classes for finite element bases. The constructors for these base classes can be used to create user defined finite elements. ","category":"page"},{"location":"public/basis/","page":"-","title":"-","text":"TensorBasis\nNonTensorBasis","category":"page"},{"location":"public/basis/#LFAToolkit.TensorBasis","page":"-","title":"LFAToolkit.TensorBasis","text":"TensorBasis(\n    numbernodes1d,\n    numberquadraturepoints1d,\n    numbercomponents,\n    dimension,\n    nodes1d,\n    quadraturepoints1d,\n    quadratureweights1d,\n    interpolation1d,\n    gradient1d\n)\n\nTensor product basis\n\nArguments:\n\nnumbernodes1d:            number of nodes in 1 dimension\nnumberquadraturepoints1d: number of quadrature points in 1 dimension\nnumbercomponents:         number of components\ndimension:                dimension of the basis\nnodes1d:                  coordinates of the nodes in 1 dimension\nquadraturepoints1d:       coordinates of the quadrature points in 1                                 dimension\nquadratureweights1d:      quadrature weights in 1 dimension\ninterpolation1d:          interpolation matrix from nodes to quadrature                                 points in 1 dimension\ngradient1d:               gradient matrix from nodes to quadrature points in                                 1 dimension\n\nReturns:\n\nTensor product basis object\n\n\n\n\n\n","category":"type"},{"location":"public/basis/#LFAToolkit.NonTensorBasis","page":"-","title":"LFAToolkit.NonTensorBasis","text":"NonTensorBasis(\n    numbernodes,\n    numberquadraturepoints,\n    numbercomponents,\n    dimension,\n    nodes,\n    quadraturepoints,\n    quadratureweights,\n    interpolation,\n    gradient\n)\n\nNon-tensor basis\n\nArguments:\n\nnumbernodes:            number of nodes \nnumberquadraturepoints: number of quadrature points\nnumbercomponents:       number of components\ndimension:              dimension of the basis\nnodes:                  coordinates of the nodes\nquadraturepoints:       coordinates of the quadrature points\nquadratureweights:      quadrature weights\ninterpolation:          interpolation matrix from nodes to quadrature points\ngradient:               gradient matrix from nodes to quadrature points\n\nReturns:\n\nNon-tensor product basis object\n\n\n\n\n\n","category":"type"},{"location":"public/basis/#Singe-Element-Bases","page":"-","title":"Singe Element Bases","text":"","category":"section"},{"location":"public/basis/","page":"-","title":"-","text":"These bases represent common tensor product finite element bases used for continuous Galerkin methods.","category":"page"},{"location":"public/basis/","page":"-","title":"-","text":"TensorH1LagrangeBasis\nTensorH1UniformBasis","category":"page"},{"location":"public/basis/#LFAToolkit.TensorH1LagrangeBasis","page":"-","title":"LFAToolkit.TensorH1LagrangeBasis","text":"TensorH1LagrangeBasis(\n    numbernodes1d,\n    numberquadraturepoints1d,\n    numbercomponents,\n    dimension,\n    lagrangequadrature = false,\n)\n\nTensor product basis on Gauss-Lobatto points with Gauss-Legendre quadrature\n\nArguments:\n\nnumbernodes1d:            number of Gauss-Lobatto nodes\nnumberquadraturepoints1d: number of Gauss-Legendre quadrature points\nnumbercomponents:         number of components\ndimension:                dimension of basis\nlagrangequadrature=false: Gauss-Lagrange or Gauss-Lobatto quadrature points,                                 default: Gauss-Lobatto\n\nReturns:\n\nH1 Lagrange tensor product basis object\n\nExample:\n\n# generate H1 Lagrange tensor product basis\nbasis = TensorH1LagrangeBasis(4, 4, 3, 2);\n\n# generate basis with Lagrange quadrature points\nbasis = TensorH1LagrangeBasis(4, 4, 3, 2, lagrangequadrature=true);\n\n# verify\nprintln(basis)\n\n# output\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 3\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#LFAToolkit.TensorH1UniformBasis","page":"-","title":"LFAToolkit.TensorH1UniformBasis","text":"TensorH1UniformBasis(\n    numbernodes1d,\n    numberquadraturepoints1d,\n    numbercomponents,\n    dimension,\n)\n\nTensor product basis on uniformly points with Gauss-Legendre quadrature\n\nArguments:\n\nnumbernodes1d:            number of uniformly spaced nodes\nnumberquadraturepoints1d: number of Gauss-Legendre quadrature points\nnumbercomponents:         number of components\ndimension:                dimension of basis\n\nReturns:\n\nH1 uniformly spaced tensor product basis object\n\nExample:\n\n# generate H1 uniformly spaced tensor product basis\nbasis = TensorH1UniformBasis(4, 3, 2, 1);\n\n# verify\nprintln(basis)\n\n# output\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 3\n    numbercomponents: 2\n    dimension: 1\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#Macro-Element-Bases","page":"-","title":"Macro-Element Bases","text":"","category":"section"},{"location":"public/basis/","page":"-","title":"-","text":"These bases represent a macro-element consisting of multiple overlapping micro elements, where the micro elements are created as above.","category":"page"},{"location":"public/basis/","page":"-","title":"-","text":"TensorH1LagrangeMacroBasis\nTensorH1UniformMacroBasis","category":"page"},{"location":"public/basis/#LFAToolkit.TensorH1LagrangeMacroBasis","page":"-","title":"LFAToolkit.TensorH1LagrangeMacroBasis","text":"TensorH1LagrangeMacroBasis(\n    numbernodes1d,\n    numberquadraturepoints1d,\n    numbercomponents,\n    dimension,\n    numberelements1d,\n    lagrangequadrature,\n)\n\nTensor product macro-element basis on Gauss-Lobatto points with Gauss-Legendre quadrature\n\nArguments:\n\nnumbernodes1d:            number of Gauss-Lobatto nodes\nnumberquadraturepoints1d: number of Gauss-Legendre quadrature points\nnumbercomponents:         number of components\ndimension:                dimension of basis\nnumberelements1d:         number of elements in macro-element\nlagrangequadrature=false: Gauss-Lagrange or Gauss-Lobatto quadrature points,                                 default: Gauss-Lobatto\n\nReturns:\n\nH1 Lagrange tensor product macro-element basis object\n\nExample:\n\n# generate H1 Lagrange tensor macro-element product basis\nbasis = TensorH1LagrangeMacroBasis(4, 4, 1, 2, 2);\n\n# generate basis with Lagrange quadrature points\nbasis = TensorH1LagrangeMacroBasis(4, 4, 1, 2, 2, lagrangequadrature=true);\n\n# verify\nprintln(basis)\n\n# output\nmacro-element tensor product basis:\n    numbernodes1d: 7\n    numberquadraturepoints1d: 8\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#LFAToolkit.TensorH1UniformMacroBasis","page":"-","title":"LFAToolkit.TensorH1UniformMacroBasis","text":"TensorH1UniformMacroBasis(\n    numbernodes1d,\n    numberquadraturepoints1d,\n    numbercomponents,\n    dimension,\n    numberelements1d,\n)\n\nTensor product macro-element basis on uniformly points with Gauss-Legendre quadrature\n\nArguments:\n\nnumbernodes1d:            number of uniformly spaced nodes\nnumberquadraturepoints1d: number of Gauss-Legendre quadrature points\nnumbercomponents:         number of components\ndimension:                dimension of basis\nnumberelements1d:         number of elements in macro-element\n\nReturns:\n\nH1 uniformly spaced tensor product macro-element basis object\n\nExample:\n\n# generate H1 uniformly spaced tensor product macro-element basis\nbasis = TensorH1UniformMacroBasis(4, 3, 1, 2, 2);\n\n# verify\nprintln(basis)\n\n# output\nmacro-element tensor product basis:\n    numbernodes1d: 7\n    numberquadraturepoints1d: 6\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#P-Prolongation-Basis","page":"-","title":"P Prolongation Basis","text":"","category":"section"},{"location":"public/basis/","page":"-","title":"-","text":"This basis provides prolongation from a single element to a single element of higher order.","category":"page"},{"location":"public/basis/","page":"-","title":"-","text":"TensorH1LagrangePProlongationBasis","category":"page"},{"location":"public/basis/#LFAToolkit.TensorH1LagrangePProlongationBasis","page":"-","title":"LFAToolkit.TensorH1LagrangePProlongationBasis","text":"TensorH1LagrangePProlongationBasis(\n    numbercoarsenodes1d,\n    numberfinenodes1d,\n    numbercomponents,\n    dimension,\n)\n\nTensor product p prolongation basis on Gauss-Lobatto points\n\nArguments:\n\nnumbercoarsenodes1d: number of coarse grid Gauss-Lobatto nodes\nnumberfinenodes1d:   number of fine grid Gauss-Lobatto nodes\nnumbercomponents:    number of components\ndimension:           dimension of basis\n\nReturns:\n\nH1 Lagrange tensor product basis object\n\nExample:\n\n# generate H1 Lagrange tensor product basis\nbasisctof = TensorH1LagrangePProlongationBasis(2, 3, 1, 2);\n\n# verify\nprintln(basisctof)\n\n# output\ntensor product basis:\n    numbernodes1d: 2\n    numberquadraturepoints1d: 3\n    numbercomponents: 1\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#H-Prolongation-Bases","page":"-","title":"H Prolongation Bases","text":"","category":"section"},{"location":"public/basis/","page":"-","title":"-","text":"These bases provide prolongation from a single element to a macro-element of the same order or a macro-element to a macro-element with a larger number of elements.","category":"page"},{"location":"public/basis/","page":"-","title":"-","text":"TensorH1LagrangeHProlongationBasis\nTensorH1UniformHProlongationBasis\nTensorH1LagrangeHProlongationMacroBasis\nTensorH1UniformHProlongationMacroBasis","category":"page"},{"location":"public/basis/#LFAToolkit.TensorH1LagrangeHProlongationBasis","page":"-","title":"LFAToolkit.TensorH1LagrangeHProlongationBasis","text":"TensorH1LagrangeHProlongationBasis(\n    numbernodes1d,\n    numbercomponents,\n    dimension,\n    numberfineelements1d,\n)\n\nTensor product h prolongation basis on Gauss-Lobatto points\n\nArguments:\n\nnumbernodes1d:            number of Gauss-Lobatto nodes per element\nnumbercomponents:         number of components\ndimension:                dimension of basis\nnumberfineelements1d:     number of fine grid elements\n\nReturns:\n\nH1 Gauss-Lobatto tensor product h prolongation basis object\n\nExample:\n\n# generate H1 Gauss-Lobatto tensor product h prolongation basis\nbasis = TensorH1LagrangeHProlongationBasis(4, 3, 2, 2);\n\n# verify\nprintln(basis)\n\n# output\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 7\n    numbercomponents: 3\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#LFAToolkit.TensorH1UniformHProlongationBasis","page":"-","title":"LFAToolkit.TensorH1UniformHProlongationBasis","text":"TensorH1UniformHProlongationBasis(\n    numbernodes1d,\n    numbercomponents,\n    dimension,\n    numberfineelements1d,\n)\n\nTensor product h prolongation basis on uniformly spaced points\n\nArguments:\n\nnumbernodes1d:            number of uniformly spaced nodes per element\nnumbercomponents:         number of components\ndimension:                dimension of basis\nnumberfineelements1d:     number of fine grid elements\n\nReturns:\n\nH1 uniformly spaced tensor product h prolongation basis object\n\nExample:\n\n# generate H1 uniformly spaced tensor product h prolongation basis\nbasis = TensorH1UniformHProlongationBasis(4, 3, 2, 2);\n\n# verify\nprintln(basis)\n\n# output\ntensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 7\n    numbercomponents: 3\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#LFAToolkit.TensorH1LagrangeHProlongationMacroBasis","page":"-","title":"LFAToolkit.TensorH1LagrangeHProlongationMacroBasis","text":"TensorH1LagrangeHProlongationMacroBasis(\n    numbernodes1d,\n    numbercomponents,\n    dimension,\n    numbercoarseelements1d,\n    numberfineelements1d,\n)\n\nTensor product macro-element h prolongation basis on Gauss-Lobatto points\n\nArguments:\n\nnumbernodes1d:            number of Gauss-Lobatto nodes per element\nnumbercomponents:         number of components\ndimension:                dimension of basis\nnumbercoarseelements1d:   number of coarse grid elements in macro-element\nnumberfineelements1d:     number of fine grid elements in macro-element\n\nReturns:\n\nH1 Gauss-Lobatto tensor product h prolongation macro-element basis object\n\nExample:\n\n# generate H1 Gauss-Lobatto tensor product h prolongation macro-element basis\nbasis = TensorH1LagrangeHProlongationMacroBasis(4, 1, 2, 2, 4);\n\n# verify\nprintln(basis)\n\n# output\nmacro-element tensor product basis:\n    numbernodes1d: 7\n    numberquadraturepoints1d: 13\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/basis/#LFAToolkit.TensorH1UniformHProlongationMacroBasis","page":"-","title":"LFAToolkit.TensorH1UniformHProlongationMacroBasis","text":"TensorH1UniformHProlongationMacroBasis(\n    numbernodes1d,\n    numbercomponents,\n    dimension,\n    numbercoarseelements1d,\n    numberfineelements1d,\n)\n\nTensor product macro-element h prolongation basis on uniformly spaced points\n\nArguments:\n\nnumbernodes1d:            number of uniformly spaced nodes per element\nnumbercomponents:         number of components\ndimension:                dimension of basis\nnumbercoarseelements1d:   number of coarse grid elements in macro-element\nnumberfineelements1d:     number of fine grid elements in macro-element\n\nReturns:\n\nH1 uniformly spaced tensor product h prolongation macro-element basis object\n\nExample:\n\n# generate H1 uniformly spaced tensor product h prolongation macro-element basis\nbasis = TensorH1UniformHProlongationMacroBasis(4, 1, 2, 2, 4);\n\n# verify\nprintln(basis)\n\n# output\nmacro-element tensor product basis:\n    numbernodes1d: 7\n    numberquadraturepoints1d: 13\n    numbercomponents: 1\n    numberelements1d: 2\n    dimension: 2\n\n\n\n\n\n","category":"function"},{"location":"public/operatorfield/#Operator-Field","page":"-","title":"Operator Field","text":"","category":"section"},{"location":"public/operatorfield/","page":"-","title":"-","text":"The operator field object represents the different inputs and outputs for the finite element operator weak form. In a Galerkin operator, inputs represent the finite element basis for unknown values and the basis evaluation modes, while the outputs represent the finite element basis for the test functions and their basis evaluation modes.","category":"page"},{"location":"public/operatorfield/","page":"-","title":"-","text":"OperatorField","category":"page"},{"location":"public/operatorfield/#LFAToolkit.OperatorField","page":"-","title":"LFAToolkit.OperatorField","text":"OperatorField(\n    basis,\n    evaluationmodes\n)\n\nFinite Element operator input or output, with a basis and evaluation mode\n\nArguments:\n\nbasis:           finite element basis for the field\nevaluationmodes: array of basis evaluation modes,                        note that quadrature weights must be listed in a                        separate operator field\n\nReturns:\n\nFinite element operator field object\n\nExample:\n\n# basis\nbasis = TensorH1LagrangeBasis(4, 3, 2, 1);\n\n# quadrature weights field, input only\nweightsfield = OperatorField(basis, [EvaluationMode.quadratureweights], \"quadrature weights\");\n\n# verify\nprintln(weightsfield)\n\n# input or output field\ninputfield = OperatorField(basis, [\n    EvaluationMode.interpolation,\n    EvaluationMode.gradient,\n    ],\n    \"gradient of weak form input\"\n);\n\n# verify\nprintln(inputfield)\n\n# output\noperator field:\n  name:\n    quadrature weights \n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 3\n    numbercomponents: 2\n    dimension: 1\n  evaluation mode:\n    quadratureweights\noperator field:\n  name:\n    gradient of weak form input\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 3\n    numbercomponents: 2\n    dimension: 1\n  evaluation modes:\n    interpolation\n    gradient\n\n\n\n\n\n","category":"type"},{"location":"release_notes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"release_notes/#v0.2.2","page":"Release Notes","title":"v0.2.2","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Relax compatibility requirement to Julia 1.3 - 1.6.","category":"page"},{"location":"release_notes/#v0.2.1","page":"Release Notes","title":"v0.2.1","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Minor bugfixes:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Gauss and Gauss-Lobatto node computation tolerances relaxed\nTypo fixes\nsrc directory reorganized to better support future development","category":"page"},{"location":"release_notes/#v0.2","page":"Release Notes","title":"v0.2","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"This release includes updated functionality and an improved interface.","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Functionality updates include:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Macro-element bases consisting of multiple micro-elements\nChebyshev preconditioning analysis\nH-multigrid analysis","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Interface improvements include:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Multi-component basis support simplified","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Additonal changes include:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Improved documentation\nExpanded examples, to include Neo-Hookean hyperelasticity\nRename primary branch to main","category":"page"},{"location":"release_notes/#v0.1.1","page":"Release Notes","title":"v0.1.1","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Minor bugfixes.","category":"page"},{"location":"release_notes/#v0.1","page":"Release Notes","title":"v0.1","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"This release includes initial basic functionality of LFAToolkit.jl.","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Functionality includes:","category":"page"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"User defined second order PDEs\nAbritrary basis order, dimension, and number of components\nIndependent mesh scaling in each dimension\nJacobi preconditioning analysis\nP-multigrid analysis","category":"page"},{"location":"public/operator/#Finite-Element-Operator","page":"-","title":"Finite Element Operator","text":"","category":"section"},{"location":"public/operator/","page":"-","title":"-","text":"The finite element operator object provides the action of the user provide weak form on the given mesh and finite element bases. This weak form follows the representation given in [2].","category":"page"},{"location":"public/operator/#Examples","page":"-","title":"Examples","text":"","category":"section"},{"location":"public/operator/","page":"-","title":"-","text":"This is an example of a scalar mass operator in two dimensions.","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex001_mass.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"Plot for the symbol of the finite element operator for the 2D scalar mass problem with cubic basis.","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"This is an example of a scalar diffusion operator in two dimensions.","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex002_diffusion.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"Plot for the symbol of the finite element operator for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"public/operator/#Documentation","page":"-","title":"Documentation","text":"","category":"section"},{"location":"public/operator/","page":"-","title":"-","text":"The finite element operator can be defined from a user defined weak form or from the gallery of weak forms for select PDEs.","category":"page"},{"location":"public/operator/","page":"-","title":"-","text":"Operator\nGalleryOperator\ncomputesymbols(::Operator, ::Array)","category":"page"},{"location":"public/operator/#LFAToolkit.Operator","page":"-","title":"LFAToolkit.Operator","text":"Operator(\n    weakform,\n    mesh,\n    inputs,\n    outputs\n)\n\nFinite element operator comprising of a weak form and bases\n\nArguments:\n\nweakform: user provided function that represents weak form at                 quadrature points\nmesh:     mesh object with deformation in each dimension\ninputs:   array of operator input fields\noutputs:  array of operator output fields\n\nReturns:\n\nFinite element operator object\n\nExample:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nbasis = TensorH1LagrangeBasis(4, 4, 1, 2);\n\nfunction massweakform(u::Array{Float64}, w::Array{Float64})\n    v = u*w[1]\n    return [v]\nend\n\n# mass operator\ninputs = [\n    OperatorField(basis, [EvaluationMode.interpolation]),\n    OperatorField(basis, [EvaluationMode.quadratureweights]),\n];\noutputs = [OperatorField(basis, [EvaluationMode.interpolation])];\nmass = Operator(massweakform, mesh, inputs, outputs);\n\n# verify\nprintln(mass)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\n\n\n\n\n\n","category":"type"},{"location":"public/operator/#LFAToolkit.GalleryOperator","page":"-","title":"LFAToolkit.GalleryOperator","text":"GalleryOperator(name, p1d, q1d, mesh)\n\nFinite element operator from a gallery of options\n\nArguments:\n\nname: string containing name of operator\np1d:  polynomial order of TensorH1LagrangeBasis\nq1d:  number of quadrature points in one dimension for basis\nmesh: mesh for operator\n\nReturns:\n\nFinite element operator object\n\nMass matrix example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"mass\", 4, 4, mesh);\n\n# verify\nprintln(mass)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\n\nDiffusion operator example:\n\n# setup\nmesh = Mesh2D(1.0, 1.0);\ndiffusion = GalleryOperator(\"diffusion\", 4, 4, mesh);\n\n# verify\nprintln(diffusion)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 4\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"public/operator/#LFAToolkit.computesymbols-Tuple{Operator, Array}","page":"-","title":"LFAToolkit.computesymbols","text":"computesymbols(operator, θ)\n\nCompute the symbol matrix for an operator\n\nArguments:\n\noperator: Finite element operator to compute symbol matrix for\nθ:              Fourier mode frequency array (one frequency per dimension)\n\nReturns:\n\nSymbol matrix for the operator\n\nExample:\n\nusing LinearAlgebra;\n\nfor dimension in 1:3\n    # setup\n    mesh = []\n    if dimension == 1\n        mesh = Mesh1D(1.0);\n    elseif dimension == 2\n        mesh = Mesh2D(1.0, 1.0);\n    elseif dimension == 3\n        mesh = Mesh3D(1.0, 1.0, 1.0);\n    end\n    diffusion = GalleryOperator(\"diffusion\", 3, 3, mesh);\n\n    # compute symbols\n    A = computesymbols(diffusion, π*ones(dimension));\n\n    # verify\n    eigenvalues = real(eigvals(A));\n    if dimension == 1\n        @assert min(eigenvalues...) ≈ 4\n        @assert max(eigenvalues...) ≈ 16/3\n    elseif dimension == 2\n        @assert min(eigenvalues...) ≈ 8/3\n        @assert max(eigenvalues...) ≈ 256/45\n    elseif dimension == 3\n        @assert min(eigenvalues...) ≈ 4/3\n        @assert max(eigenvalues...) ≈ 1024/225\n    end\nend\n\n# output\n\n\n\n\n\n\n","category":"method"},{"location":"public/operatorgallery/#Finite-Element-Operator-Gallery","page":"-","title":"Finite Element Operator Gallery","text":"","category":"section"},{"location":"public/operatorgallery/","page":"-","title":"-","text":"The following PDEs are available in the operator gallery.","category":"page"},{"location":"public/operatorgallery/#Scalar-Mass-Operator","page":"-","title":"Scalar Mass Operator","text":"","category":"section"},{"location":"public/operatorgallery/","page":"-","title":"-","text":"LFAToolkit.massoperator","category":"page"},{"location":"public/operatorgallery/#LFAToolkit.massoperator","page":"-","title":"LFAToolkit.massoperator","text":"GalleryOperator(\"mass\", p1d, q1d, mesh)\n\nConvenience constructor for scalar mass operator\n\nWeak form:\n\nint v u\n\nArguments:\n\np1d:  polynomial order of TensorH1LagrangeBasis\nq1d:  number of quadrature points in one dimension for basis\nmesh: mesh for operator\n\nReturns:\n\nMass matrix operator of order p on mesh\n\nExample:\n\n# mass operator\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"mass\", 3, 4, mesh);\n\n# verify\nprintln(mass)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n   \n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    interpolation\n\n\n\n\n\n","category":"function"},{"location":"public/operatorgallery/#Vector-Mass-Operator","page":"-","title":"Vector Mass Operator","text":"","category":"section"},{"location":"public/operatorgallery/","page":"-","title":"-","text":"LFAToolkit.vectormassoperator","category":"page"},{"location":"public/operatorgallery/#LFAToolkit.vectormassoperator","page":"-","title":"LFAToolkit.vectormassoperator","text":"GalleryOperator(\"vectormass\", p1d, q1d, mesh)\n\nConvenience constructor for vector mass operator in three components\n\nWeak form:\n\nint mathbfv mathbfu\n\nArguments:\n\np1d:  polynomial order of TensorH1LagrangeBasis\nq1d:  number of quadrature points in one dimension for basis\nmesh: mesh for operator\n\nReturns:\n\nVector mass matrix operator of order p on mesh\n\nExample:\n\n# mass operator\nmesh = Mesh2D(1.0, 1.0);\nmass = GalleryOperator(\"vectormass\", 3, 4, mesh);\n\n# verify\nprintln(mass)\n\n# output\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 3\n    dimension: 2\n  evaluation mode:\n    interpolation\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 3\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 3\n    dimension: 2\n  evaluation mode:\n    interpolation\n\n\n\n\n\n","category":"function"},{"location":"public/operatorgallery/#Scalar-Diffusion-Operator","page":"-","title":"Scalar Diffusion Operator","text":"","category":"section"},{"location":"public/operatorgallery/","page":"-","title":"-","text":"LFAToolkit.diffusionoperator","category":"page"},{"location":"public/operatorgallery/#LFAToolkit.diffusionoperator","page":"-","title":"LFAToolkit.diffusionoperator","text":"GalleryOperator(\"diffusion\", p1d, q1d, mesh)\n\nConvenience constructor for scalar diffusion operator\n\nWeak form:\n\nint nabla v nabla u\n\nArguments:\n\np1d:  polynomial order of TensorH1LagrangeBasis\nq1d:  number of quadrature points in one dimension for basis\nmesh: mesh for operator\n\nReturns:\n\nDiffusion operator of order p on mesh\n\nExample:\n\n# mass operator\nmesh = Mesh2D(1.0, 1.0);\ndiffusion = GalleryOperator(\"diffusion\", 3, 4, mesh);\n\n# verify\nprintln(diffusion)\n\n# output\n\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n   \n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 1\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"public/operatorgallery/#Vector-Diffusion-Operator","page":"-","title":"Vector Diffusion Operator","text":"","category":"section"},{"location":"public/operatorgallery/","page":"-","title":"-","text":"LFAToolkit.vectordiffusionoperator","category":"page"},{"location":"public/operatorgallery/#LFAToolkit.vectordiffusionoperator","page":"-","title":"LFAToolkit.vectordiffusionoperator","text":"GalleryOperator(\"vectordiffusion\", p1d, q1d, mesh)\n\nConvenience constructor for vector diffusion operator in three components\n\nWeak form:\n\nint nabla mathbfv nabla mathbfu\n\nArguments:\n\np1d:  polynomial order of TensorH1LagrangeBasis\nq1d:  number of quadrature points in one dimension for basis\nmesh: mesh for operator\n\nReturns:\n\nVector diffusion operator of order p on mesh\n\nExample:\n\n# mass operator\nmesh = Mesh2D(1.0, 1.0);\ndiffusion = GalleryOperator(\"vectordiffusion\", 3, 4, mesh);\n\n# verify\nprintln(diffusion)\n\n# output\n\nfinite element operator:\n2d mesh:\n    dx: 1.0\n    dy: 1.0\n\n2 inputs:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 3\n    dimension: 2\n  evaluation mode:\n    gradient\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 3\n    dimension: 2\n  evaluation mode:\n    quadratureweights\n\n1 output:\noperator field:\n  tensor product basis:\n    numbernodes1d: 3\n    numberquadraturepoints1d: 4\n    numbercomponents: 3\n    dimension: 2\n  evaluation mode:\n    gradient\n\n\n\n\n\n","category":"function"},{"location":"public/evaluationmode/#Basis-Evaluation-Mode","page":"-","title":"Basis Evaluation Mode","text":"","category":"section"},{"location":"public/evaluationmode/","page":"-","title":"-","text":"This enum lists the supported basis evaluation modes for finite element operator fields. Note that the quadrature weights evaluation mode can only be used in an input field.","category":"page"},{"location":"public/evaluationmode/","page":"-","title":"-","text":"EvaluationMode.EvalMode","category":"page"},{"location":"public/evaluationmode/#LFAToolkit.EvaluationMode.EvalMode","page":"-","title":"LFAToolkit.EvaluationMode.EvalMode","text":"Basis evaluation mode for operator inputs and outputs\n\nModes:\n\ninterpolation:     values interpolated to quadrature points\ngradient:          derivatives evaluated at quadrature points\nquadratureweights: quadrature weights\n\nExample:\n\nEvaluationMode.EvalMode\n\n# output\nEnum LFAToolkit.EvaluationMode.EvalMode:\ninterpolation = 0\ngradient = 1\nquadratureweights = 2\n\n\n\n\n\n","category":"type"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section documents the LFAToolkit examples.","category":"page"},{"location":"examples/#Contents","page":"Examples","title":"Contents","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages = [\n    \"examples/diffusion.md\",\n    \"examples/solidmechanics.md\",\n]","category":"page"},{"location":"examples/diffusion/#Diffusion-operator","page":"-","title":"Diffusion operator","text":"","category":"section"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of various preconditioners for the 2D scalar diffusion problem.","category":"page"},{"location":"examples/diffusion/#Problem-formulation","page":"-","title":"Problem formulation","text":"","category":"section"},{"location":"examples/diffusion/","page":"-","title":"-","text":"The scalar diffusion problem is given by","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"nabla^2 u = f","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"with a weak form of","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"int_Omega nabla u nabla v = int_Omega v f forall v in V","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"for an appropriate test space V subseteq H_0^1 left( Omega right) on the domain. In this weak formulation, boundary terms have been omitted, as they are not present on the infinite grid for Local Fourier Analysis.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"Plot for the symbol of the finite element operator for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"examples/diffusion/#LFAToolkit-code","page":"-","title":"LFAToolkit code","text":"","category":"section"},{"location":"examples/diffusion/","page":"-","title":"-","text":"The diffusion operator is the classical test case for multigrid preconditioners and solvers.","category":"page"},{"location":"examples/diffusion/#Jacobi","page":"-","title":"Jacobi","text":"","category":"section"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of a Jacobi smoother.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex101_jacobi.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"Plot for the symbol of a Jacobi smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"examples/diffusion/#Chebyshev","page":"-","title":"Chebyshev","text":"","category":"section"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of a Chebyshev smoother.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex111_chebyshev.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"Plot for the symbol of a cubic Chebyshev smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"examples/diffusion/#P-Multigrid","page":"-","title":"P-Multigrid","text":"","category":"section"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of a two level p-multigrid preconditioner.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex201_pmultigrid.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"Example plot for the symbol of p-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of a multilevel p-multigrid preconditioner.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex202_pmultigrid_multilevel.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"Example plot for the symbol of multilevel p-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with cubic basis.","category":"page"},{"location":"examples/diffusion/#H-Multigrid","page":"-","title":"H-Multigrid","text":"","category":"section"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of a two level h-multigrid preconditioner.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex211_hmultigrid.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"Example plot for the symbol of h-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with linear basis.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"This is an example of a multilevel h-multigrid preconditioner.","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"../../../examples/ex212_hmultigrid_multilevel.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"examples/diffusion/","page":"-","title":"-","text":"Example plot for the symbol of multilevel h-multigrid with a cubic Chebyshev smoother for the 2D scalar diffusion problem with linear basis.","category":"page"},{"location":"public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"This section documents the public API of the LFAToolkit.","category":"page"},{"location":"public/#Contents","page":"Public API","title":"Contents","text":"","category":"section"},{"location":"public/#Finite-Element-Operators","page":"Public API","title":"Finite Element Operators","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Pages = [\n    \"public/mesh.md\",\n    \"public/basis.md\",\n    \"public/evaluationmode.md\",\n    \"public/operatorfield.md\",\n    \"public/operator.md\",\n    \"public/operatorgallery.md\",\n]","category":"page"},{"location":"public/#Preconditioners","page":"Public API","title":"Preconditioners","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Pages = [\n    \"public/pc/identity.md\",\n    \"public/pc/jacobi.md\",\n    \"public/pc/chebyshev.md\",\n    \"public/pc/multigrid.md\",\n]","category":"page"},{"location":"background/#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Local Fourier Analysis (LFA) was first used by Brandt [1] to analyze the convergence of multi-level adaptive techniques for solving PDEs discretized with finite differences, but the technique has been adapted for multi-level and multi-grid techniques using finite element discretizations. While this library focuses on the finite element discretizations, finite difference discretizations of PDEs can often be recovered from finite element formulations by using linear finite elements on a structured grid. This fact makes LFAToolkit.jl an extremely flexible tool for LFA.","category":"page"},{"location":"background/#Local-Fourier-Analysis","page":"Mathematical Background","title":"Local Fourier Analysis","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"LFA considers the local properties of the descretized system via its Fourier modes and the eigenvalues of the associated symbol matrix. We will describe the arbitrary degree, one dimensional scalar case and extend it to an arbitrary dimension and number of components finite element problem.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"First consider a scalar Toeplitz operator L_h on an infinite one dimensional uniform grid G_h, This operator is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"L_h mathrelhat= left s_kappa right_h left( kappa in V right)\nL_h w_h left( x right) = sum_kappa in V s_kappa w_h left( x + kappa h right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where V subset mathcalZ is a finite index set, s_kappa in mathcalR are constant coefficients and w_h left( x right) is a l^2 function on G_h.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"As L_h is Toeplitz, it can be diagonalized by the standard Fourier modes varphi left( theta x right) = e^imath theta x  h.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"If for all grid functions varphi left( theta x right) we have","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"L_h varphi left( theta x right) = tildeL_h left( theta right) varphi left( theta x right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"then tildeL_h left( theta right) = sum_kappa in V s_kappa e^imath theta kappa is the symbol of L_h.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"We can extend this to a p times p linear system of operators representing a scalar problem on a p order finite element","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeL_h =\nbeginbmatrix\n    tildeL_h^1 1    cdots    tildeL_h^1 p  \n    vdots                vdots    vdots              \n    tildeL_h^p 1    cdots    tildeL_h^p p  \nendbmatrix","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where tildeL_h^i j is given by a scalar Toeplitz operator describing how component j appears in the equation for component i.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"The spectral radius of the symbol of an error propagation operator determines how rapidly a relaxation scheme decreases error at a target frequency for a given parameter value. In this context, low frequencies are given by theta in T^low = left - pi  2 pi  2 right) and high frequencies are given by theta in T^high = left - pi  2 3 pi  2 right) setminus T^low.","category":"page"},{"location":"background/#High-Order-Finite-Elements","page":"Mathematical Background","title":"High Order Finite Elements","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Consider the specific case of a Topeliz operator representing a scalar PDE in 1D with the weak formulation given by Brown in [2],","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"int_Omega v cdot f_0 left( u nabla u right) + nabla v  f_1 left( u nabla u right) = int_Omega f v forall v in V","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"for some suitable V subseteq H_0^1 left( Omega right). In this equation, cdot represents contraction over fields and  represents contraction over fields and spatial dimensions, both of which are omitted for the sake of clarity in this initial derivation. Boundary terms have been omitted, as they are not present on the infinite uniform grid G_h.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Selecting a finite element basis, we can discretize the weak form and produce","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"A u = b","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Using the algebraic representation of PDE operators discussed in [2], the PDE operator A is of the form","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"A = P^T A_e P","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"A_e = B^T D B","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where P represents the element assembly operator, B is a basis operator which computes the values and derivatives of the basis functions at the quadrature points, and D is a block diagonal operator which provides a pointwise application of the bilinear form on the quadrature points, to include quadrature weights and the change in coordinates between the physical and reference space.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"We can thus compute the symbol matrix as","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeA_h = Q^T left( A_e odot left e^imath left( x_i - x_j right) theta  h right right) Q","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where odot represents pointwise multiplication of the elements, h is the length of the element, and i j in left 0 1 dots p right. Q is a p + 1 times p matrix that localizes Fourier modes on an element.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Q =\nbeginbmatrix\n    I    \n    e_0  \nendbmatrix =\nbeginbmatrix\n    1         0         cdots    0       \n    0         1         cdots    0       \n    vdots    vdots    vdots    vdots  \n    0         0         cdots    1       \n    1         0         cdots    0       \nendbmatrix","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"This same computation of the symbol matrix extends to more complex PDE with multiple components and in higher dimensions.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Multiple components are supported by extending the p times p system of Toeplitz operators given above to a ncomp cdot p times ncomp cdot p system of operators.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Tensor products are used to extend this analysis into higher dimensions. The basis evaluation operators in higher dimensions are given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"B_interp2d = B_interp otimes B_interp\nB_grad2d =\nbeginbmatrix\n    B_grad otimes B_interp  \n    B_interp otimes B_grad  \nendbmatrix","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where B_interp and B_grad represent 1D basis interpolation and gradient operators, respectively.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Similarly, the localization of Fourier modes in higher dimensions is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Q_2d = Q otimes Q","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"and an analogous computation can be done for 3D.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Therefore, the symbol matrix for a PDE with arbitrary dimension, order and number of components is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeA_h = Q^T left( A_e odot left e^imath sum_d left( mathbfx_i - mathbfx_j right) mathbftheta  mathbfh right right) Q","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where odot represents pointwise multiplication of the elements, h is the length of the element in each dimension, and i j in left 0 1 dots p right. Q is a p - 1 times p matrix that localizes the Fourier modes on the element.","category":"page"},{"location":"background/#Multigrid","page":"Mathematical Background","title":"Multigrid","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Multigrid follows the following algorithm:","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"pre-smooth   : u_i = u_i + M^-1 left( b - A u_i right)\nrestrict     : r_c = R_ftoc left( b - A u_i right)\ncoarse solve : A_c e_c = r_c\nprolongate   : u_i = u_i + P_ctof e_c\npost-smooth  : u_i = u_i + M^-1 left( b - A u_i right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where f and c represent the fine and coarse grids, respectively, R_ftoc represents the grid restriction operator, P_ctof represents the grid prolongation operator.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"The total multigrid error propagation operator is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"M_TMG = S_f left( I - P_ctof A_c^-1 R_ftoc A_f right) S_f","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where S_f represents the error propagation operator for the smoother on the fine grid.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"This algorithm describes both h-multigrid and p-multigrid. While h-multigrid coarsens the mesh by increasing the size of each element, p-multigrid coarsens the mesh by decreasing the order of each element.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"To explore the convergence of multigrid techniques, we need to analyze the symbol of the multigrid error propagation operator. We build the symbol of the p-multigrid error propagation operator in parts.","category":"page"},{"location":"background/#Smoothing-Operator","page":"Mathematical Background","title":"Smoothing Operator","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Multigrid techniques require error relaxation techniques. The error propagation operator for a relaxation technique is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"S = I - M^-1 A","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"In the specific case of Jacobi smoothing, M is given by M = diag left( A right).","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"The symbol of the error propagation operator is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeS_h left( omega theta right) = I - tildeM_h^-1 left( omega right) tildeA_h left( theta right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where omega is a relaxation parameter.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Specifically, for Jacobi we have","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeS_h left( omega theta right) = I - omega tildeM_h^-1 tildeA_h left( theta right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where omega is the weighting factor and tildeM_h is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeM_h = Q^T diag left( A_e right) Q","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"If multiple pre or post-smoothing passes are used, we have","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeS_h left( omega nu theta right) = left( I - omega tildeM_h^-1 tildeA_h left( theta right) right)^nu","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where nu is the number of smoothing passes.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"More sophisticated smoothers can be used, such as the Chebyshev semi-iterative method. For discussion of the error propegation of the Chebyshev semi-iteative method, see Gutknecht and Röllin [3]. User defined smoothers are supported, where the user provides M^-1 or a function computing M^-1 based upon A, and tildeM^-1_h and tildeS_h are automatically generated and used inside the multigrid symbol matrix.","category":"page"},{"location":"background/#Grid-Transfer-Operators","page":"Mathematical Background","title":"Grid Transfer Operators","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"We consider grid transfer operators for p-type multigrid. The finite element operator for prolongation from the lower order coarse grid to the high order fine grid is given by ","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"P_ctof = P_f^T P_e P_c\nP_e = D_scale B_ctof","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where B_ctof is a basis interpolation from the coarse basis to the fine basis, P_f is the fine grid element assembly operator, P_c is the coarse grid element assembly operator, and D_scale is a scaling operator to account for node multiplicity across element interfaces.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Restriction from the fine grid to the coarse grid is given by the transpose, R_ftoc = P_ctof^T.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Thus, the symbol of P_ctof is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeP_ctof left( theta right) = Q_f^T left( left( D_scale B_ctof right) odot left e^imath sum_d left( mathbfx_i f - mathbfx_j c right) mathbftheta  mathbfh right right) Q_c","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"and tildeR_ftoc is given by the analogous computation","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeR_ftoc left( theta right) = Q_c^T left( left( D_scale B_ctof right)^T odot left e^imath sum_d left( mathbfx_i c - mathbfx_j f right) mathbftheta  mathbfh right right) Q_f","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"The grid transfer operators for h-multgrid can be represented in a similar fashion by representing the fine grid as consisting of macro-elements that consist of multiple micro elements of the same polynomial order as the coarse grid elements.","category":"page"},{"location":"background/#Multigrid-Error-Propagation-Symbol","page":"Mathematical Background","title":"Multigrid Error Propagation Symbol","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Combining these elements, the symbol of the error propagation operator for p-multigrid is given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"tildeE_TMG left( omega nu theta right) = tildeS_f left( omega nu theta right) left I - tildeP_ctof left( theta right) tildeA_c^-1 left( theta right) tildeR_ftoc left( theta right) tildeA_f left( theta right) right tildeS_f left( omega nu theta right)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"where tildeP_ctof and tildeR_ftoc are given above, tildeS_f is given by the smoothing operator, and tildeA_c and tildeA_f are derived from the PDE being analyzed.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"This can be extended to multi-level analysis by applying this analysis recursively, keeping in mind that tildeE_TMG is the symbol of the multigrid error propagation operator. The symbol of the multigrid operator is computed by noting that E = I - M A.","category":"page"},{"location":"#LFAToolkit","page":"Introduction","title":"LFAToolkit","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Local Fourier Analysis for arbitrary order finite element type operators","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Local Fourier Analysis (LFA) is a tool commonly used in the analysis of multigrid and multilevel algorithms for solving partial differential equations via finite element or finite difference methods. This analysis can be used to predict convergence rates and optimize parameters in multilevel methods and preconditioners.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This library provides a toolkit for analyzing the performance of preconditioners for arbitrary, user provided weak forms of partial differential equations. While this library focuses on the finite element discretizations, finite difference discretizations of PDEs can often be recovered from finite element formulations by using linear finite elements on a structured grid. This fact makes LFAToolkit.jl an extremely flexible tool for LFA.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Example plot for the symbol of p-multigrid with a Jacobi smoother for the 2D scalar diffusion problem.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"background.md\",\n    \"examples.md\",\n    \"public.md\",\n    \"private.md\",\n    \"release_notes.md\",\n    \"references.md\"\n]\nDepth = 1","category":"page"},{"location":"private/mesh/#Rectangular-Mesh","page":"-","title":"Rectangular Mesh","text":"","category":"section"},{"location":"private/mesh/","page":"-","title":"-","text":"LFAToolkit.Mesh","category":"page"},{"location":"private/mesh/#LFAToolkit.Mesh","page":"-","title":"LFAToolkit.Mesh","text":"Rectangular mesh with independent scaling in each dimesion\n\n\n\n\n\n","category":"type"}]
}
